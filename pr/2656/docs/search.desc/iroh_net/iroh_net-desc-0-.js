searchState.loadedDescShard("iroh_net", 0, "Peer-to-peer connectivity based on QUIC.\nNetwork paths to contact an iroh-net node.\nNetwork-level addressing information for an iroh-net node.\nThe identifier for a node in the (iroh) network.\nApplies the options to <code>self</code>.\nApplies the options to <code>self</code>.\nDefault values used in <code>iroh-net</code>\nA dialer to conveniently dial many nodes.\nReturns the direct addresses of this peer.\nSocket addresses where the peer might be reached directly.\nNode address discovery.\nThis module exports a DNS resolver, which is also the …\nThe <code>Endpoint</code> allows establishing connections to other …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>NodeAddr</code> from its parts.\nAddressing information to connect to <code>Self::node_id</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this addressing information is empty.\nCryptographic key handling for <code>iroh-net</code>.\nCo-locating all of the iroh-net metrics structs\nNetworking related utilities\nChecks the network conditions from the current host.\nCreates a new <code>NodeAddr</code> with empty <code>AddrInfo</code>.\nThe node’s identifier.\nAllows sending ICMP echo requests to a host in order to …\nPort mapping client and service.\nPackage <code>relay</code> implements a revised version of the …\nReturns the relay url of this peer.\nThe node’s home relay url.\nSTUN packets sending and receiving.\nInternal utilities to support testing.\nTickets supported by iroh-net\nTLS configuration based on libp2p TLS specs.\nUtilities used in <code>iroh-net</code>\nAdds the given direct addresses to the peer’s <code>AddrInfo</code>.\nAdds a relay url to the node’s <code>AddrInfo</code>.\nThe default HTTPS port used by the Relay server.\nThe default HTTP port used by the Relay server.\nThe default metrics port used by the Relay server.\nThe default STUN port used by the Relay server.\nProduction configuration.\nStaging configuration.\nHostname of the default Asia-Pacific relay.\nHostname of the default EU relay.\nHostname of the default NA relay.\nGet the default <code>RelayNode</code> for Asia-Pacific\nGet the default <code>RelayNode</code> for EU.\nGet the default <code>RelayNode</code> for NA.\nGet the default <code>RelayMap</code>.\nHostname of the default EU relay.\nHostname of the default NA relay.\nGet the default <code>RelayNode</code> for EU.\nGet the default <code>RelayNode</code> for NA.\nGet the default <code>RelayMap</code>.\nDials nodes and maintains a queue of pending dials.\nAborts a pending dial.\nReturns a reference to the endpoint used in this dialer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if a node is currently being dialed.\nCreate a new dialer for a <code>Endpoint</code>\nWaits for the next dial operation to complete.\nNumber of pending connections to be opened.\nStarts to dial a node by <code>NodeId</code>.\nA discovery service that combines multiple discovery …\nNode discovery for <code>super::Endpoint</code>.\nThe results returned from <code>Discovery::resolve</code>.\nName used for logging when new node addresses are added …\nAdds a <code>Discovery</code> service.\nThe address info for the node being resolved.\nDNS node discovery for iroh-net\nCreates an empty <code>ConcurrentDiscovery</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>ConcurrentDiscovery</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOptional timestamp when this node address info was last …\nA discovery service that uses an mdns-like service to …\nA discovery service which publishes and resolves node …\nA static string to identify the discovery source.\nPublishes the given <code>AddrInfo</code> to the discovery mechanism.\nResolves the <code>AddrInfo</code> for the given <code>NodeId</code>.\nSubscribe to all addresses that get discovered.\nDNS node discovery\nThe n0 testing DNS node origin, for production.\nThe n0 testing DNS node origin, for testing.\nTesting DNS node origin, must run server from …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new DNS discovery using the <code>iroh.link</code> domain.\nCreates a new DNS discovery.\nDiscovery using <code>swarm-discovery</code>, a variation on mdns\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>LocalSwarmDiscovery</code> Service.\nDefault TTL for the records in the pkarr signed packet. …\nInterval in which we will republish our node info even if …\nThe pkarr relay run by n0, for production.\nThe pkarr relay run by n0, for testing.\nPublish node info to a pkarr relay.\nA pkarr client to publish <code>pkarr::SignedPacket</code>s to a pkarr …\nResolve node info using a pkarr relay.\nPkarr based node discovery for iroh-net\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a pkarr publisher which uses the …\nCreate a pkarr resolver which uses the …\nCreate a new config with a secret key and a pkarr relay …\nCreate a new config with a pkarr relay URL.\nCreate a new client.\nPublish a <code>SignedPacket</code>\nResolve a <code>SignedPacket</code>\nPublish <code>AddrInfo</code> about this node to a pkarr relay.\nCreate a new <code>PkarrPublisher</code> with a custom time-to-live …\nBuilder for PkarrNodeDiscovery.\nA discovery mechanism for iroh-net based on …\nBuild the discovery mechanism.\nCreate a new builder for PkarrNodeDiscovery.\nExplicitly set the pkarr client to use.\nSet whether to publish to the mainline DHT.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet whether to include the direct addresses in the DNS …\nSet the initial delay before the first publish.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUse the default pkarr relay URL.\nSet the pkarr relay URL to use.\nSet the republish delay for the DHT.\nSet the secret key to use for signing the DNS packets.\nSet the time-to-live value for the DNS packets.\nThe DNS resolver type used throughout <code>iroh-net</code>.\nExtension trait to <code>DnsResolver</code>.\nGet a reference to the default DNS resolver.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by DNS name.\nLooks up node info by DNS name.\nLooks up node info by DNS name in a staggered fashion.\nLooks up node info by DNS name in a staggered fashion.\nPerform an ipv4 lookup with a timeout.\nRace an ipv4 and ipv6 lookup with a timeout.\nResolve IPv4 and IPv6 in parallel.\nRace an ipv4 and ipv6 lookup with a timeout in a staggered …\nRace an ipv4 and ipv6 lookup with a timeout in a staggered …\nPerform an ipv4 lookup with a timeout in a staggered …\nPerform an ipv4 lookup with a timeout in a staggered …\nPerform an ipv6 lookup with a timeout.\nPerform an ipv6 lookup with a timeout in a staggered …\nPerform an ipv6 lookup with a timeout in a staggered …\nSupport for handling DNS resource records for dialing by …\nGet the DNS resolver used within iroh-net.\nDirect address.\nThe DNS name for the iroh TXT record.\nThe attributes supported by iroh for <code>IROH_TXT_NAME</code> DNS …\nInformation about the iroh node contained in an …\nURL of home relay.\nAttributes parsed from <code>IROH_TXT_NAME</code> TXT records.\nReturns the parsed attributes.\nAny direct addresses.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>NodeInfo</code> from a set of DNS records.\nParses a set of DNS resource records.\nCreates <code>TxtAttrs</code> from a node id and an iterator of …\nParses a <code>NodeInfo</code> from a <code>pkarr::SignedPacket</code>.\nParses a <code>pkarr::SignedPacket</code>.\nCreates <code>TxtAttrs</code> from a node id and an iterator of “…\nParses a <code>NodeId</code> from [<code>z-base-32</code>] encoding.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLooks up attributes by <code>NodeId</code> and origin domain.\nLooks up attributes by DNS name.\nCreates a new <code>NodeInfo</code> from its parts.\nReturns the node id.\nThe <code>NodeId</code>.\nThe advertised home relay server.\nConverts into a <code>hickory_proto::rr::Record</code> DNS record.\nConverts to a list of <code>hickory_proto::rr::Record</code> resource …\nCreates a <code>pkarr::SignedPacket</code>.\nCreates a <code>pkarr::SignedPacket</code>\nEncodes a <code>NodeId</code> in [<code>z-base-32</code>] encoding.\nFuture produced by <code>Endpoint::accept</code>.\nNetwork paths to contact an iroh-net node.\nApplication layer added the node directly.\nReason given by an application for closing the connection\nThe peer closed the connection\nBuilder for <code>Endpoint</code>.\nWe received a CallMeMaybe.\nThe connection could not be created because not enough of …\nThe stream has already been stopped, finished, or reset\nThe stream has already been finished or reset\nIn-progress connection attempt future\nA QUIC connection.\nReason given by the transport for closing the connection\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nThe connection was lost\nThe connection was lost\nThe type of connection we have to the endpoint.\nStream returning <code>ConnectionTypes</code>\nThe type of control message we have received.\nDirect UDP connection\nA <em>direct address</em> on which an iroh-node might be …\nInformation about a <em>direct address</em>.\nThe type of direct address.\nStream returning local endpoints as they change.\nControls an iroh-net node, establishing connections with …\nAttempted an ordered read following an unordered read\nAn incoming connection for which the server has not yet …\nAdaptor to let <code>Incoming</code> be <code>await</code>ed like a <code>Connecting</code>.\nA locally bound socket address.\nThe local application closed the connection\nThe largest representable value\nThe largest encoded value length\nBoth a UDP and a relay connection are used.\nApplication layer with a specific name added the node …\nNetwork-level addressing information for an iroh-net node.\nWe have no verified connection to this PublicKey\nWe received a Ping from the node.\nWe received a Pong from the node.\nAn address assigned by the router using port mapping.\nErrors that arise from reading from a stream.\nA stream that can only be used to receive data\nRelay connection over relay\nNode communicated with us first via relay.\nDetails about a remote iroh-net node which is known to …\nThe peer abandoned transmitting data on this stream\nThe peer is unable to continue processing this connection, …\nError for attempting to retry an <code>Incoming</code> which already …\nNode was loaded from the fs.\nA stream that can only be used to send data\nParameters governing incoming connections\nSource for a new node.\nThe peer is no longer accepting data on this stream\nPublic internet address discovered via STUN.\nHard NAT: STUN’ed IPv4 address + local fixed port.\nCommunication with the peer has lapsed for longer than the …\nParameters governing the core QUIC state machine\nThe peer violated the QUIC specification as understood by …\nNode communicated with us first via UDP.\nNot yet determined..\nAn integer less than 2^62\nThe peer doesn’t implement any supported version\nErrors that arise from writing to a stream\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nAccepts an incoming connection on the endpoint.\nAttempts to accept this incoming connection (an error may …\nAccept the next incoming bidirectional stream\nAccept the next incoming uni-directional stream\nAccepts this incoming connection using a custom …\nSpecifies the ACK frequency config (see <code>AckFrequencyConfig</code> …\nInforms this <code>Endpoint</code> about addresses of the iroh-net node.\nInforms this <code>Endpoint</code> about addresses of the iroh-net …\nThe UDP address reported by the remote node.\nThe address.\nThe addresses at which this node might be reachable.\nWhether the implementation is permitted to set the spin …\nExtracts the ALPN protocol from the peer’s handshake …\nSets the ALPN protocols that this endpoint will accept on …\nBinds the magic endpoint on the specified socket address.\nReturns the local socket addresses on which the underlying …\nReturns the builder for an <code>Endpoint</code>, with a production …\nClose the connection immediately.\nCloses the QUIC endpoint and the magic socket.\nIf the connection is closed, the reason why.\nWait for the connection to be closed for any reason\nHow to construct new <code>congestion::Controller</code>s\nCurrent state of the congestion control algorithm, for …\nThe type of connection we have to the node, either direct …\nReturns a stream that reports connection type changes for …\nConnects to a remote <code>Endpoint</code>.\nConnects to a remote endpoint, using just the nodes’s …\nTLS configuration used for incoming connections.\nMaximum quantity of out-of-order crypto layer data to …\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nBytes available in the outgoing datagram buffer\nReturns the default relay mode.\nReturns the direct addresses of this <code>Endpoint</code>.\nSocket addresses where the peer might be reached directly.\nOptionally sets a discovery mechanism for this endpoint.\nReturns the discovery mechanism, if configured.\nOptionally sets a custom DNS resolver to use for this …\nReturns the DNS resolver used in this <code>Endpoint</code>.\nWhether to use “Generic Segmentation Offload” to …\nClass of error as encoded in the specification\nApplication-specific reason code\nDerive keying material from this connection’s TLS …\nNotify the peer that no more data will ever be written to …\nType of frame that caused the close\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nExtract the <code>PublicKey</code> from the peer’s TLS certificate.\nParameters negotiated during the handshake\nParameters negotiated during the handshake\nWhether there is a possible known network path to the …\nReturns the <code>RelayUrl</code> of the Relay server used as home …\nGet the identity of this stream\nGet the identity of this stream\nIgnores this incoming connection attempt, not sending any …\nMaximum number of received bytes to buffer for each …\nMaximum number of received bytes to buffer for all <code>Incoming</code>\nAddressing information to connect to <code>Self::node_id</code>.\nThe initial value to be used as the maximum UDP payload …\nThe RTT used before an RTT sample is taken\nSkip verification of SSL certificates from relay servers\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a 0-RTT or 0.5-RTT connection at the cost of …\nGet the <code>Incoming</code>\nExtract the integer value\nCheck if this stream has been opened during 0-RTT.\nReturns true if the <code>Source::NamedApp</code> is the same as the …\nPeriod of inactivity before sending a keep-alive packet\nEnables saving the TLS pre-master key for connections.\nOptionally set a list of known nodes.\nElapsed time since this network path was known to exist.\nLast control message received by this node about this …\nElapsed time since the last payload message was received …\nGet the duration since the last activity we received from …\nTime elapsed time since last we have sent to or received …\nThe latency to the remote node over this network path.\nThe latency of the current network path to the remote node.\nThe local IP address which was used when the peer …\nReturns the local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nCreates a <code>quinn::ServerConfig</code> with the given secret key …\nMaximum number of incoming bidirectional streams that may …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nCompute the maximum size of datagrams that may be passed …\nMaximum duration of inactivity to accept before timing out …\nMaximum number of <code>Incoming</code> to allow to exist at a time\nWhether to allow clients to migrate to new addresses\nThe maximum UDP payload size guaranteed to be supported by …\nSpecifies the MTU discovery config (see <code>MtuDiscoveryConfig</code> …\nNotifies the system of potential network changes.\nCreate a default config with a particular handshake token …\nReturns the current <code>NodeAddr</code> for this endpoint.\nReturns the node id of this endpoint.\nThe node’s identifier.\nThe globally unique identifier for this node.\nInitiate a new outgoing bidirectional stream.\nInitiate a new outgoing unidirectional stream.\nMaximum reordering in packet number space before FACK …\nCryptographic identity of the peer\nNumber of consecutive PTOs after which network is …\nAttempts to read from the stream into buf.\nAttempt to write bytes from buf into the stream.\nThe preferred IPv4 address that will be communicated to …\nThe preferred IPv6 address that will be communicated to …\nGet the priority of the send stream\nSets the proxy url from the environment, in this order:\nSets an explicit proxy url to proxy all HTTP(S) traffic …\nRead data contiguously from the stream.\nRead the next segment of data\nRead the next segments of data\nReceive an application datagram\nRead an exact number of bytes contiguously from the stream.\nConvenience method to read all remaining data into a buffer\nHuman-readable reason for the close\nHuman-readable reason for the close\nMaximum number of bytes the peer may transmit across all …\nCompletes when the stream has been reset by the peer or …\nReturn all nodes discovered in the last <code>duration</code>.\nRejects this incoming connection attempt.\nSets the relay servers to assist in establishing …\nThe node’s home relay url.\nRelay server information, if available.\nThe peer’s UDP address\nReturns the peer’s UDP address.\nThe peer’s UDP address.\nWhether the socket address that is initiating this …\nReturns information about the remote node identified by a …\nReturns information about all the remote nodes this …\nClose the send stream immediately.\nResponds with a retry packet.\nDuration after a stateless retry token was issued for …\nCurrent best estimate of this connection’s latency …\nSets a secret key to authenticate with other peers.\nReturns the secret_key of this endpoint.\nTransmit <code>data</code> as an unreliable, unordered application …\nTransmit <code>data</code> as an unreliable, unordered application …\nMaximum number of bytes to transmit to a peer without …\nSets the list of accepted ALPN protocols.\nModify the number of remotely initiated bidirectional …\nModify the number of remotely initiated unidirectional …\nSet the priority of the send stream\nSee <code>proto::TransportConfig::receive_window()</code>\nList of places we have learned about this remote as well …\nA stable identifier for this connection\nReturns connection statistics\nStop accepting data\nCompletes when the peer stops the stream or reads the …\nMaximum number of bytes the peer may transmit without …\nMaximum reordering in time space before time based loss …\nPrivate key used to authenticate data included in …\nTransport configuration to use for incoming connections\nSet a custom <code>TransportConfig</code>\nSets a custom <code>quinn::TransportConfig</code> for this endpoint.\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nThe origin of this direct address.\nWatches for changes to the home relay.\nReturns a weak reference to the inner connection struct.\nCreate a server config with the given <code>crypto::ServerConfig</code>\nCreate a server config with the given certificate chain to …\nWrite bytes to the stream\nConvenience method to write an entire buffer to the stream\nConvenience method to write an entire list of chunks to …\nConvenience method to write a single chunk in its entirety …\nWrite chunks to the stream\nThe name of the application that added the node\nSize of an encoded Ed25519 signature in bytes.\nError when decoding the base32.\nError when decoding the public key.\nError when deserialising a <code>PublicKey</code> or a <code>SecretKey</code>.\nThe identifier for a node in the (iroh) network.\nThe length of an ed25519 <code>PublicKey</code>, in bytes.\nA public key.\nA secret key.\nShared Secret.\nEd25519 signature.\nGet this public key as a byte array.\nConvert to a base32 string limited to the first 10 bytes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse an Ed25519 signature from a byte slice.\nConstruct a <code>PublicKey</code> from a slice of bytes.\nCreate a secret key from its byte representation.\nParse an Ed25519 signature from its <code>R</code> and <code>s</code> components.\nParse an Ed25519 signature from a byte slice.\nGenerate a new <code>SecretKey</code> with the default randomness …\nGenerate a new <code>SecretKey</code> with a randomness generator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpens the ciphertext, which must have been created using …\nThe public key of this <code>SecretKey</code>.\nBytes for the <code>R</code> component of a signature.\nBytes for the <code>s</code> component of a signature.\nSeals the provided cleartext.\nReturns the shared key for communication between this key …\nSign the given message and return a digital signature\nReturn the inner byte array.\nConvert this to the bytes representing the secret part. …\nSerialise this key to OpenSSH format.\nConvert this signature into a byte vector.\nDeserialise this key from OpenSSH format.\nVerify a signature on a message with this secret key’s …\nEnum of metrics for the module\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe number of direct connections we have made to peers.\nThe number of direct connections we have lost to peers.\nThe number of connections to peers we have added over …\nThe number of connections to peers we have removed over …\nNumber of QUIC datagrams received.\nNumber of datagrams received using GRO\nIp family selection between Ipv4 and Ipv6.\nWrapper around a tokio UDP socket that handles the fact …\nIpv4\nIpv6\nBind to the given port and listen on all interfaces.\nBind to any provided <code>SocketAddr</code>.\nBind to the given port only on localhost.\nBind only Ipv4 on localhost.\nBind only Ipv6 on localhost.\nBind only Ipv4 on any interface.\nBind only Ipv6 on any interface.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIP address related utilities.\nReturns the matching localhost address.\nMonitoring of networking interfaces and route changes.\nReturns the matching default address.\nList of machine’s IP addresses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true if the address is a unicast address with …\nLoopback addresses.\nReturns the machine’s IP addresses. If there are no …\nRegular addresses.\nToken to remove a callback\nMonitors networking interface and route changes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPotential change detected outside\nCreate a new monitor.\nSubscribe to network changes.\nUnsubscribe a callback from network changes, using the …\nClient to run netchecks.\nEnum of metrics for the module\nLatencies per relay node.\nA netcheck report.\nCaptivePortal is set when we think there’s a captive …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRuns a netcheck, returning the report.\nGet report with channel\nip:port of global IPv4\n<code>[ip]:port</code> of global IPv6\nWhether the router supports communicating between two …\nAn ICMPv4 round trip completed, <code>None</code> if not checked.\nAn ICMPv6 round trip completed, <code>None</code> if not checked.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn IPv4 STUN round trip completed.\nan IPv4 packet was able to be sent\nAn IPv6 STUN round trip completed.\nAn IPv6 packet was able to be sent\nReturns an iterator over all the relays and their …\nWhether STUN results depend on which STUN server you’re …\nWhether STUN results depend on which STUN server you’re …\nCreates a new netcheck client.\ncould bind a socket to ::1\nProbe indicating the presence of port mapping protocols on …\n<code>None</code> for unknown\nPass a received STUN packet to the netchecker.\nkeyed by relay Url\nkeyed by relay Url\nkeyed by relay Url\nA UDP STUN round trip completed.\nCould not create client, probably bind error.\nCould not send ping.\nWhether this error was because we couldn’t create a …\nAllows sending ICMP echo requests to a host in order to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new Pinger.\nSend a ping request with associated data, returning the …\nPort mapping client.\nConfigures which port mapping protocols are enabled in the …\nEnum of metrics for the module\nOutput of a port mapping probe.\nA port mapping client.\nIndicates if all port mapping protocols are available.\nDeactivate port mapping.\nBy default all port mapping protocols are enabled.\nWhether PMP is enabled.\nWhether PCP is enabled.\nWhether UPnP is enabled.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf PMP can be considered available.\nCreate a new port mapping client.\nIf PCP can be considered available.\nRequest a probe to the port mapping protocols.\nTry to get a mapping for the last local port if there isn…\nUpdate the local port.\nIf UPnP can be considered available.\nWatch the external address for changes in the mappings.\nThe inner actor is gone, likely means things are shutdown.\nThe relay <code>super::client::Client</code> failed to build\nThis <code>Client</code> cannot acknowledge pings\nThe client is closed\nThere was a connection timeout error\nUse a custom relay map.\nUse the default relay map, with production relay servers …\nThere was an error dialing\nThere was an error from the task doing the dialing\nDisable relay servers completely.\nThere was an error with DNS resolution\nThere was a timeout resolving DNS.\nA one-way message from server to client, declaring the …\nThere was an http error <code>http::Error</code>.\nAn HTTP Relay client.\nBuild a Client.\nPossible connection errors on the <code>Client</code>\nReceiving end of a <code>Client</code>.\nThere was http server <code>hyper::Error</code>\nBoth IPv4 and IPv6 are disabled for this relay node\nThe given <code>Url</code> is invalid\nA one-way empty message from server to client, just to …\nThe maximum size of a packet sent over relay. (This only …\nThere no underlying relay <code>super::client::Client</code> client …\nNo local addresses exist\nNo relay nodes are available with that name\nIndicates that the client identified by the underlying …\nRequest from a client or server to reply to the other side …\nThe ping request was aborted\nThe ping request timed out\nReply to a <code>ReceivedMessage::Ping</code> from a client or server …\nThe connection failed to proxy\nThere was an error receiving a packet\nThe type of message received by the <code>Conn</code> from a relay …\nRepresents an incoming packet.\nA connection to a relay server.\nConfiguration of all the relay servers that can be used.\nConfiguration of the relay servers for an <code>Endpoint</code>.\nInformation on a specific relay server.\nNo relay nodes are available\nA URL identifying a relay server.\nThere was an error sending a packet\nA one-way message from server to client, advertising that …\nUse the staging relay servers from n0.\nThe relay node specified only allows STUN requests\nThere was an unexpected status code\nThe connection failed to upgrade\nAn error related to websockets, either errors with parsing …\nReturns if we should prefer ipv6 it replaces the …\nBuild the <code>Client</code>\nEnable this <code>Client</code> to acknowledge pings.\nClose the connection\nClose the http relay connection.\nDisconnect the http relay connection.\nConnect to a relay Server and returns the underlying relay …\nIs this a known node?\nCreates a new `RelayMap with a single relay server …\nCreate an empty relay map.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs the [<code>RelayMap] from an iterator of [</code>RelayNode`]…\nReturns a [<code>RelayMap] from a [</code>RelayUrl`].\nGet the given node.\nHTTP-specific constants for the relay server and client.\nSkip the verification of the relay server’s SSL …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether or not this <code>Conn</code> is closed.\nReturns <code>true</code> if the underlying relay connection is …\nAre there any nodes in this map?\nIndicate this client is the preferred way to communicate …\nIndicates this client is a prober\nHow many nodes are known?\nThe local address that the <code>Conn</code> is listening on.\nGet the local addr of the connection. If there is no …\nCreate a new <code>ClientBuilder</code>\nReturns an <code>Iterator</code> over all known nodes.\nSends a packet that tells the server whether this …\nLet the server know that this client is the preferred …\nSend a ping to the server. Return once we get an expected …\nSets whether to connect to the relay via websockets or not.\nSet an explicit proxy url to proxy all HTTP(S) traffic …\nThe public key for this client\nReads a message from the server. Returns the message and …\nReturns the relay map for this mode.\nSends a packet to the node identified by <code>dstkey</code>\nSend a packet to the server.\nSend a ping with 8 bytes of random data.\nRespond to a ping request. The <code>data</code> field should be filled …\nSend a pong back to the server.\nA fully-fledged iroh-relay server over HTTP or HTTPS.\nThe expected <code>PublicKey</code> of the relay server we are …\nSets the server url\nWhether this relay server should only be used for STUN …\nThe stun port of the relay server.\nThe <code>RelayUrl</code> where this relay server can be dialed.\nReturns the sorted relay URLs.\nThe received packet bytes.\nIf set, is a description of why the connection is …\nAn advisory duration that the client should wait before …\nThe <code>PublicKey</code> of the packet sender.\nAn advisory duration for how long the client should …\nThe HTTP upgrade protocol used for relaying.\nThe HTTP path under which the relay accepts relaying …\nThe HTTP path under which the relay allows doing latency …\nRelays over the custom relaying protocol with a custom …\nRelays over websockets.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTries to match the value of an HTTP upgrade header to …\nThe HTTP upgrade header used or expected.\nTLS certificate configuration.\nHandle incoming connections to the Server.\nUse Let’s Encrypt.\nRate limits.\nUse a static TLS key and certificate chain.\nThe main underlying IO stream type used for the relay …\nMetrics tracked for the relay server\nA plain non-Tls <code>tokio::net::TcpStream</code>\nConfiguration for the Relay HTTP and HTTPS server.\nA running Relay + STUN server.\nThe task for a running server actor.\nConfiguration for the full Relay &amp; STUN server.\nConfiguration for the STUN server.\nA Tls wrapped <code>tokio::net::TcpStream</code>\nTLS configuration for Relay server.\nAborts the server.\nAdds a new connection to the server and serves it.\nBurst limit for accepting new connection. Unlimited if not …\nRate limit for accepting new connection. Unlimited if not …\nNumber of connections we have accepted\nThe socket address on which the STUN server should bind.\nBytes received from a <code>FrameType::SendPacket</code>\nBytes sent from a <code>FrameType::SendPacket</code>\nMode for getting a cert.\nCreate a <code>ClientConnHandler</code>, which can verify connections …\nCloses the server and waits for the connections to …\nNumber of accepted ‘iroh derp http’ connection upgrades\n<code>FrameType::SendPacket</code> dropped that are disco messages\n<code>FrameType::SendPacket</code> received that are disco messages\n<code>FrameType::SendPacket</code> sent that are disco messages\nNumber of connections we have removed because of an error\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNumber of <code>FrameType::Ping</code>s received\nThe socket address the HTTP server is listening on.\nThe socket address on which the Relay HTTP server should …\nThe socket address the HTTPS server is listening on.\nThe socket address on which to serve the HTTPS server.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether or not the relay <code>ServerActorTask</code> is closed.\nRate limits.\nReturns the server metadata cert that can be sent by the …\nSocket to serve metrics on.\nTODO: replace with builder\nPackets of other <code>FrameType</code>s dropped\nPackets of other <code>FrameType</code>s received\nPackets of other <code>FrameType</code>s sent\nReturns the server’s public key.\nConfiguration for the Relay server, disabled if <code>None</code>.\nReturns the server’s secret key.\nThe iroh secret key of the Relay server.\n<code>FrameType::SendPacket</code> dropped, that are not disco messages\n<code>FrameType::SendPacket</code> received, that are not disco messages\n<code>FrameType::SendPacket</code> sent, that are not disco messages\nNumber of <code>FrameType::Pong</code>s sent\nRequests graceful shutdown.\nStarts the server.\nConfiguration for the STUN server, disabled if <code>None</code>.\nThe socket address the STUN server is listening on.\nReturns the handle for the task.\nTLS configuration for the HTTPS server.\nNumber of unique client keys per day\nNumber of <code>FrameType::Unknown</code> received\nNumber of accepted websocket connections\nThe TLS certificate chain.\nConfiguration for Let’s Encrypt certificates.\nThe TLS private key.\nThe <code>AlternateServer</code>atribute\nErrors that can occur when handling a STUN packet.\nThe <code>ErrorCode</code>atribute\nerror response\nThe <code>Fingerprint</code>atribute\nindication\nSTUN request had bogus fingerprint.\nThe STUN message could not be parsed or is otherwise …\nSTUN response has malformed attributes.\nThe <code>MappedAddress</code>atribute\nThe STUN message class. Although there are four message …\nClass used to decode STUN messages\nThe <code>MessageIntegrity</code>atribute\nThe <code>MessageIntegritySha256</code>atribute\nSTUN request didn’t end in fingerprint.\nThe <code>Nonce</code>atribute\nSTUN request is not a binding request when it should be.\nSTUN packet is not a response when it should be.\nThe <code>PasswordAlgorithm</code>atribute\nThe <code>PasswordAlgorithms</code>atribute\nThe <code>Realm</code>atribute\nrequest\nThe <code>Software</code>atribute\nSTUN Attributes that can be attached to a <code>StunMessage</code>\nDescribes an error decoding a <code>StunMessage</code>\nsuccess response\nThe transaction ID is a 96-bit identifier, used to …\nThe <code>Unknown</code>atribute\nThe <code>UnknownAttributes</code>atribute\nThe <code>UserHash</code>atribute\nThe <code>UserName</code>atribute\nThe <code>XorMappedAddress</code>atribute\nReturns a reference to the internal attribute value or an …\nReturns a reference to the bytes that represents the …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns the STUN attribute type of this instance.\nDecodes the STUN raw buffer\nCreates a cryptographically random transaction ID chosen …\nReturns a reference to the <code>AlternateServer</code> attribute.\nReturns a reference to the <code>ErrorCode</code> attribute.\nReturns a reference to the <code>Fingerprint</code> attribute.\nReturns a reference to the <code>MappedAddress</code> attribute.\nReturns a reference to the <code>MessageIntegrity</code> attribute.\nReturns a reference to the <code>MessageIntegritySha256</code> …\nReturns a reference to the <code>Nonce</code> attribute.\nReturns a reference to the <code>PasswordAlgorithm</code> attribute.\nReturns a reference to the <code>PasswordAlgorithms</code> attribute.\nReturns a reference to the <code>Realm</code> attribute.\nReturns a reference to the <code>Software</code> attribute.\nReturns a reference to the <code>Unknown</code> attribute.\nReturns a reference to the <code>UnknownAttributes</code> attribute.\nReturns a reference to the <code>UserHash</code> attribute.\nReturns a reference to the <code>UserName</code> attribute.\nReturns a reference to the <code>XorMappedAddress</code> attribute.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the context associated to this decoder\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReports whether b is a STUN message.\nReturns true if this <code>StunAttribute</code> is <code>AlternateServer</code>\nReturns true if this <code>StunAttribute</code> is <code>ErrorCode</code>\nReturns true if this <code>StunAttribute</code> is <code>Fingerprint</code>\nReturns true if this <code>StunAttribute</code> is <code>MappedAddress</code>\nReturns true if this <code>StunAttribute</code> is <code>MessageIntegrity</code>\nReturns true if this <code>StunAttribute</code> is …\nReturns true if this <code>StunAttribute</code> is <code>Nonce</code>\nReturns true if this <code>StunAttribute</code> is <code>PasswordAlgorithm</code>\nReturns true if this <code>StunAttribute</code> is <code>PasswordAlgorithms</code>\nReturns true if this <code>StunAttribute</code> is <code>Realm</code>\nReturns true if this <code>StunAttribute</code> is <code>Software</code>\nReturns true if this <code>StunAttribute</code> is <code>Unknown</code>\nReturns true if this <code>StunAttribute</code> is <code>UnknownAttributes</code>\nReturns true if this <code>StunAttribute</code> is <code>UserHash</code>\nReturns true if this <code>StunAttribute</code> is <code>UserName</code>\nReturns true if this <code>StunAttribute</code> is <code>XorMappedAddress</code>\nSTUN Methods Registry\nParses a STUN binding request.\nParses a successful binding response STUN packet. The IP …\nGenerates a binding request STUN packet.\nGenerates a binding response.\nBinding\nReserved\nShared secret\nA drop guard to clean up test infrastructure.\nHandle and drop guard for test DNS and Pkarr servers.\nCreate a DNS resolver with a single nameserver.\nCreate a <code>ConcurrentDiscovery</code> with <code>DnsDiscovery</code> and …\nCreate a <code>DnsResolver</code> configured to use the test DNS server.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe socket address of the DNS server.\nThe node origin domain.\nWait until a Pkarr announce for a node is published to the …\nThe HTTP URL of the Pkarr server.\nRun DNS and Pkarr servers on localhost.\nRuns a relay server with STUN enabled suitable for tests.\nRun DNS and Pkarr servers on localhost with the specified …\nA token containing everything to get a file from the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new ticket.\nThe <code>NodeAddr</code> of the provider for this ticket.\nError generating the certificate.\nError creating QUIC config.\nError for generating iroh p2p TLS configs.\nX.509 certificate handling.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a TLS client configuration.\nCreate a TLS server configuration.\nAn error that occurs during certificate generation.\nAn X.509 certificate with a libp2p-specific extension is …\nThe contents of the specific libp2p extension, containing …\nAn error that occurs during certificate parsing.\nAn error that occurs during signature verification.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a self-signed TLS certificate that includes a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttempts to parse the provided bytes as a <code>P2pCertificate</code>.\nThe <code>PublicKey</code> of the remote peer.\nVerify the <code>signature</code> of the <code>message</code> signed by the secret …\nA join handle that owns the task it is running, and aborts …\nHolds a handle to a task and aborts it on drop.\nResolves to pending if the inner is <code>None</code>.\nA join handle that owns the task it is running, and aborts …\nIO utility to chain <code>AsyncRead</code>s together.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFuture to be polled.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>CancelOnDrop</code> with a name and a handle to a task.\nStream for the <code>chain</code> method.\nChain two <code>AsyncRead</code>s together.\nReturns the argument unchanged.\nGets mutable references to the underlying readers in this …\nGets pinned mutable references to the underlying readers …\nGets references to the underlying readers in this <code>Chain</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>Chain</code>, returning the wrapped readers.")