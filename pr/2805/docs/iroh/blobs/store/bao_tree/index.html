<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Efficient BLAKE3 based verified streaming"><title>iroh::blobs::store::bao_tree - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-b21aa549bf6d91ff.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="iroh" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.0-nightly (c987ad527 2024-05-01)" data-channel="nightly" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../static.files/storage-e32f0c247825364d.js"></script><script defer src="../../../../crates.js"></script><script defer src="../../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../iroh/index.html">iroh</a><span class="version">0.27.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In iroh::blobs::store</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../../iroh/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a href="../../../index.html">iroh</a>::<wbr><a href="../../index.html">blobs</a>::<wbr><a href="../index.html">store</a>::<wbr><a class="mod" href="#">bao_tree</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="efficient-blake3-based-verified-streaming"><a class="doc-anchor" href="#efficient-blake3-based-verified-streaming">§</a>Efficient BLAKE3 based verified streaming</h2>
<p>This crate is similar to the <a href="https://crates.io/crates/bao">bao crate</a>, but
takes a slightly different approach.</p>
<p>The core struct is <a href="struct.BaoTree.html" title="struct iroh::blobs::store::bao_tree::BaoTree">BaoTree</a>, which describes the geometry of the tree and
various ways to traverse it. An individual tree node is identified by
<a href="struct.TreeNode.html" title="struct iroh::blobs::store::bao_tree::TreeNode">TreeNode</a>, which is just a newtype wrapper for an u64.</p>
<p><a href="struct.TreeNode.html" title="struct iroh::blobs::store::bao_tree::TreeNode">TreeNode</a> provides various helpers to e.g. get the offset of a node in
different traversal orders.</p>
<p>There are newtypes for the different kinds of integers used in the
tree:
<a href="struct.ChunkNum.html" title="struct iroh::blobs::store::bao_tree::ChunkNum">ChunkNum</a> is an u64 number of chunks,
<a href="struct.TreeNode.html" title="struct iroh::blobs::store::bao_tree::TreeNode">TreeNode</a> is an u64 tree node identifier,
and <a href="struct.BlockSize.html" title="struct iroh::blobs::store::bao_tree::BlockSize">BlockSize</a> is the log base 2 of the chunk group size.</p>
<p>All this is then used in the <a href="io/index.html" title="mod iroh::blobs::store::bao_tree::io">io</a> module to implement the actual io, both
<a href="io/sync/index.html" title="mod iroh::blobs::store::bao_tree::io::sync">synchronous</a> and <a href="io::tokio">asynchronous</a>.</p>
<h2 id="basic-usage"><a class="doc-anchor" href="#basic-usage">§</a>Basic usage</h2>
<p>The basic workflow is like this: you have some existing data, for which
you want to enable verified streaming. This data can either be in memory,
in a file, or even a remote resource such as an HTTP server.</p>
<h3 id="outboard-creation"><a class="doc-anchor" href="#outboard-creation">§</a>Outboard creation</h3>
<p>You create an outboard using the <a href="io/sync/trait.CreateOutboard.html" title="trait iroh::blobs::store::bao_tree::io::sync::CreateOutboard">CreateOutboard</a>
trait. It has functions to <a href="io/sync/trait.CreateOutboard.html#method.create" title="associated function iroh::blobs::store::bao_tree::io::sync::CreateOutboard::create">create</a> an
outboard from scratch or to <a href="io/sync/trait.CreateOutboard.html#tymethod.init_from" title="method iroh::blobs::store::bao_tree::io::sync::CreateOutboard::init_from">initialize</a>
data and root hash from existing data.</p>
<h3 id="serving-requests"><a class="doc-anchor" href="#serving-requests">§</a>Serving requests</h3>
<p>You serve streaming requests by using the
<a href="io/sync/fn.encode_ranges.html" title="fn iroh::blobs::store::bao_tree::io::sync::encode_ranges">encode_ranges</a> or
<a href="io/sync/fn.encode_ranges_validated.html" title="fn iroh::blobs::store::bao_tree::io::sync::encode_ranges_validated">encode_ranges_validated</a> functions
in the sync or async io module. For this you need data and a matching
outboard.</p>
<p>The difference between the two functions is that the validated version
will check the hash of each chunk against the bao tree encoded in the
outboard, so you will detect data corruption before sending out data
to the requester. When using the unvalidated version, you might send out
corrupted data without ever noticing and earn a bad reputation.</p>
<p>Due to the speed of the blake3 hash function, validation is not a
significant performance overhead compared to network operations and
encryption.</p>
<p>The requester will send a set of chunk ranges they are interested in.
To compute chunk ranges from byte ranges, there is a helper function
<a href="io/fn.round_up_to_chunks.html" title="fn iroh::blobs::store::bao_tree::io::round_up_to_chunks">round_up_to_chunks</a> that takes a byte range and
rounds up to chunk ranges.</p>
<p>If you just want to stream the entire blob, you can use <a href="../range_collections/struct.RangeSet.html#method.all" title="associated function iroh::blobs::store::range_collections::RangeSet::all">ChunkRanges::all</a>
as the range.</p>
<h3 id="processing-requests"><a class="doc-anchor" href="#processing-requests">§</a>Processing requests</h3>
<p>You process requests by using the <a href="io/sync/fn.decode_ranges.html" title="fn iroh::blobs::store::bao_tree::io::sync::decode_ranges">decode_ranges</a>
function in the sync or async io module. This function requires prior
knowledge of the tree geometry (total data size and block size). A common
way to get this information is to have the block size as a common parameter
of both sides, and send the total data size as a prefix of the encoded data.
E.g. the original bao crate uses a little endian u64 as the prefix.</p>
<p>This function will perform validation in any case, there is no variant
that skips validation since that would defeat the purpose of verified
streaming.</p>
<h3 id="simple-end-to-end-example"><a class="doc-anchor" href="#simple-end-to-end-example">§</a>Simple end to end example</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bao_tree::{
    io::{
        outboard::PreOrderOutboard,
        round_up_to_chunks,
        sync::{decode_ranges, encode_ranges_validated, valid_ranges, CreateOutboard},
    },
    BlockSize, ByteRanges, ChunkRanges,
};
<span class="kw">use </span>std::io;

<span class="doccomment">/// Use a block size of 16 KiB, a good default for most cases
</span><span class="kw">const </span>BLOCK_SIZE: BlockSize = BlockSize::from_chunk_log(<span class="number">4</span>);

<span class="comment">// The file we want to serve
</span><span class="kw">let </span>file = std::fs::File::open(<span class="string">"video.mp4"</span>)<span class="question-mark">?</span>;
<span class="comment">// Create an outboard for the file, using the current size
</span><span class="kw">let </span>ob = PreOrderOutboard::&lt;Vec&lt;u8&gt;&gt;::create(<span class="kw-2">&amp;</span>file, BLOCK_SIZE)<span class="question-mark">?</span>;
<span class="comment">// Encode the first 100000 bytes of the file
</span><span class="kw">let </span>ranges = ByteRanges::from(<span class="number">0</span>..<span class="number">100000</span>);
<span class="kw">let </span>ranges = round_up_to_chunks(<span class="kw-2">&amp;</span>ranges);
<span class="comment">// Stream of data to client. Needs to implement `io::Write`. We just use a vec here.
</span><span class="kw">let </span><span class="kw-2">mut </span>to_client = <span class="macro">vec!</span>[];
encode_ranges_validated(<span class="kw-2">&amp;</span>file, <span class="kw-2">&amp;</span>ob, <span class="kw-2">&amp;</span>ranges, <span class="kw-2">&amp;mut </span>to_client)<span class="question-mark">?</span>;

<span class="comment">// Stream of data from client. Needs to implement `io::Read`. We just wrap the vec in a cursor.
</span><span class="kw">let </span>from_server = io::Cursor::new(to_client);
<span class="kw">let </span>root = ob.root;
<span class="kw">let </span>tree = ob.tree;

<span class="comment">// Decode the encoded data into a file
</span><span class="kw">let </span><span class="kw-2">mut </span>decoded = std::fs::File::create(<span class="string">"copy.mp4"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>ob = PreOrderOutboard {
    tree,
    root,
    data: <span class="macro">vec!</span>[],
};
decode_ranges(from_server, <span class="kw-2">&amp;</span>ranges, <span class="kw-2">&amp;mut </span>decoded, <span class="kw-2">&amp;mut </span>ob)<span class="question-mark">?</span>;

<span class="comment">// the first 100000 bytes of the file should now be in `decoded`
// in addition, the required part of the tree to validate that the data is
// correct are in `ob.data`

// Print the valid ranges of the file
</span><span class="kw">for </span>range <span class="kw">in </span>valid_ranges(<span class="kw-2">&amp;</span>ob, <span class="kw-2">&amp;</span>decoded, <span class="kw-2">&amp;</span>ChunkRanges::all()) {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, range);
}</code></pre></div>
<h2 id="async-end-to-end-example"><a class="doc-anchor" href="#async-end-to-end-example">§</a>Async end to end example</h2>
<p>The async version is very similar to the sync version, except that it needs
an async context. All functions that do IO are async. The file has to be
an [iroh_io::File], which is just a wrapper for <a href="https://doc.rust-lang.org/nightly/std/fs/struct.File.html" title="struct std::fs::File">std::fs::File</a> that implements
async random access via the <a href="io/fsm/trait.AsyncSliceReader.html" title="trait iroh::blobs::store::bao_tree::io::fsm::AsyncSliceReader">AsyncSliceReader</a> trait.</p>
<p>We use [futures_lite] crate, but using the normal futures crate will also work.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bao_tree::{
    io::{
        outboard::PreOrderOutboard,
        round_up_to_chunks,
        fsm::{decode_ranges, encode_ranges_validated, valid_ranges, CreateOutboard},
    },
    BlockSize, ByteRanges, ChunkRanges,
};
<span class="kw">use </span>bytes::BytesMut;
<span class="kw">use </span>futures_lite::StreamExt;
<span class="kw">use </span>std::io;

<span class="doccomment">/// Use a block size of 16 KiB, a good default for most cases
</span><span class="kw">const </span>BLOCK_SIZE: BlockSize = BlockSize::from_chunk_log(<span class="number">4</span>);

<span class="comment">// The file we want to serve
</span><span class="kw">let </span><span class="kw-2">mut </span>file = iroh_io::File::open(<span class="string">"video.mp4"</span>.into()).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="comment">// Create an outboard for the file, using the current size
</span><span class="kw">let </span><span class="kw-2">mut </span>ob = PreOrderOutboard::&lt;BytesMut&gt;::create(<span class="kw-2">&amp;mut </span>file, BLOCK_SIZE).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="comment">// Encode the first 100000 bytes of the file
</span><span class="kw">let </span>ranges = ByteRanges::from(<span class="number">0</span>..<span class="number">100000</span>);
<span class="kw">let </span>ranges = round_up_to_chunks(<span class="kw-2">&amp;</span>ranges);
<span class="comment">// Stream of data to client. Needs to implement `io::Write`. We just use a vec here.
</span><span class="kw">let </span><span class="kw-2">mut </span>to_client = Vec::new();
encode_ranges_validated(file, <span class="kw-2">&amp;mut </span>ob, <span class="kw-2">&amp;</span>ranges, <span class="kw-2">&amp;mut </span>to_client).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// Stream of data from client. Needs to implement `io::Read`. We just wrap the vec in a cursor.
</span><span class="kw">let </span>from_server = io::Cursor::new(to_client.as_slice());
<span class="kw">let </span>root = ob.root;
<span class="kw">let </span>tree = ob.tree;

<span class="comment">// Decode the encoded data into a file
</span><span class="kw">let </span><span class="kw-2">mut </span>decoded = iroh_io::File::open(<span class="string">"copy.mp4"</span>.into()).<span class="kw">await</span><span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>ob = PreOrderOutboard {
    tree,
    root,
    data: BytesMut::new(),
};
decode_ranges(from_server, ranges, <span class="kw-2">&amp;mut </span>decoded, <span class="kw-2">&amp;mut </span>ob).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="comment">// the first 100000 bytes of the file should now be in `decoded`
// in addition, the required part of the tree to validate that the data is
// correct are in `ob.data`

// Print the valid ranges of the file
</span><span class="kw">let </span>ranges = ChunkRanges::all();
<span class="kw">let </span><span class="kw-2">mut </span>stream = valid_ranges(<span class="kw-2">&amp;mut </span>ob, <span class="kw-2">&amp;mut </span>decoded, <span class="kw-2">&amp;</span>ranges);
<span class="kw">while let </span><span class="prelude-val">Some</span>(range) = stream.next().<span class="kw">await </span>{
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, range);
}</code></pre></div>
<h2 id="compatibility-with-the-bao-crate"><a class="doc-anchor" href="#compatibility-with-the-bao-crate">§</a>Compatibility with the <a href="https://crates.io/crates/bao">bao crate</a></h2>
<p>This crate will be compatible with the bao crate, provided you do the
following:</p>
<ul>
<li>use a block size of 1024, so no chunk groups</li>
<li>use a little endian u64 as the prefix for the encoded data</li>
<li>use only a single range</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="blake3/index.html" title="mod iroh::blobs::store::bao_tree::blake3">blake3</a></div><div class="desc docblock-short">The official Rust implementation of the <a href="https://blake3.io">BLAKE3</a> cryptographic hash
function.</div></li><li><div class="item-name"><a class="mod" href="io/index.html" title="mod iroh::blobs::store::bao_tree::io">io</a></div><div class="desc docblock-short">Implementation of bao streaming for std io and tokio io</div></li><li><div class="item-name"><a class="mod" href="iter/index.html" title="mod iroh::blobs::store::bao_tree::iter">iter</a></div><div class="desc docblock-short">Iterators over BaoTree nodes</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BaoTree.html" title="struct iroh::blobs::store::bao_tree::BaoTree">BaoTree</a></div><div class="desc docblock-short">Defines a Bao tree.</div></li><li><div class="item-name"><a class="struct" href="struct.BlockSize.html" title="struct iroh::blobs::store::bao_tree::BlockSize">BlockSize</a></div><div class="desc docblock-short">A block size.</div></li><li><div class="item-name"><a class="struct" href="struct.ChunkNum.html" title="struct iroh::blobs::store::bao_tree::ChunkNum">ChunkNum</a></div><div class="desc docblock-short">A number of blake3 chunks.</div></li><li><div class="item-name"><a class="struct" href="struct.TreeNode.html" title="struct iroh::blobs::store::bao_tree::TreeNode">TreeNode</a></div><div class="desc docblock-short">An u64 that defines a node in a bao tree.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.PostOrderOffset.html" title="enum iroh::blobs::store::bao_tree::PostOrderOffset">PostOrderOffset</a></div><div class="desc docblock-short">An offset of a node in a post-order outboard</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.ByteRanges.html" title="type iroh::blobs::store::bao_tree::ByteRanges">ByteRanges</a></div><div class="desc docblock-short">A set of byte ranges</div></li><li><div class="item-name"><a class="type" href="type.ChunkRanges.html" title="type iroh::blobs::store::bao_tree::ChunkRanges">ChunkRanges</a></div><div class="desc docblock-short">A set of chunk ranges</div></li><li><div class="item-name"><a class="type" href="type.ChunkRangesRef.html" title="type iroh::blobs::store::bao_tree::ChunkRangesRef">ChunkRangesRef</a></div><div class="desc docblock-short">A referenceable set of chunk ranges</div></li></ul></section></div></main></body></html>