searchState.loadedDescShard("iroh_net", 0, "Peer-to-peer connectivity based on QUIC.\nNetwork paths to contact an iroh-net node.\nNetwork-level addressing information for an iroh-net node.\nThe identifier for a node in the (iroh) network.\nApplies the options to <code>self</code>.\nApplies the options to <code>self</code>.\nDefault values used in <code>iroh-net</code>\nA dialer to conveniently dial many nodes.\nReturns the direct addresses of this peer.\nSocket addresses where the peer might be reached directly.\nContains the discovery message types.\nNode address discovery.\nThis module exports a DNS resolver, which is also the …\nThe <code>Endpoint</code> allows establishing connections to other …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>NodeAddr</code> from its parts.\nAddressing information to connect to <code>Self::node_id</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this addressing information is empty.\nCryptographic key handling for <code>iroh-net</code>.\nImplements a socket that can change its communication path …\nCo-locating all of the iroh-net metrics structs\nNetworking related utilities\nChecks the network conditions from the current host.\nCreates a new <code>NodeAddr</code> with empty <code>AddrInfo</code>.\nThe node’s identifier.\nAllows sending ICMP echo requests to a host in order to …\nPort mapping client and service.\nPackage <code>relay</code> implements a revised version of the …\nReturns the relay url of this peer.\nThe node’s home relay url.\nSTUN packets sending and receiving.\nInternal utilities to support testing.\nTickets supported by iroh-net\nTLS configuration based on libp2p TLS specs.\nUtilities used in <code>iroh-net</code>\nAdds the given direct addresses to the peer’s <code>AddrInfo</code>.\nAdds a relay url to the node’s <code>AddrInfo</code>.\nThe default HTTPS port used by the Relay server.\nThe default HTTP port used by the Relay server.\nThe default metrics port used by the Relay server.\nThe default STUN port used by the Relay server.\nProduction configuration.\nStaging configuration.\nHostname of the default Asia-Pacific relay.\nHostname of the default EU relay.\nHostname of the default NA relay.\nGet the default <code>RelayNode</code> for Asia-Pacific\nGet the default <code>RelayNode</code> for EU.\nGet the default <code>RelayNode</code> for NA.\nGet the default <code>RelayMap</code>.\nHostname of the default EU relay.\nHostname of the default NA relay.\nGet the default <code>RelayNode</code> for EU.\nGet the default <code>RelayNode</code> for NA.\nGet the default <code>RelayMap</code>.\nDials nodes and maintains a queue of pending dials.\nAborts a pending dial.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if a node is currently being dialed.\nCreate a new dialer for a <code>Endpoint</code>\nWaits for the next dial operation to complete.\nNumber of pending connections to be opened.\nStarts to dial a node by <code>NodeId</code>.\nMessage sent only over the relay to request that the …\nHeader: Type | Version\nThe 6 byte header of all discovery messages.\nA discovery message.\nA response a Ping.\nRelay Url.\nAddresses to which we can send. This is either a UDP or a …\nUDP, the ip addr.\nCurrent Version.\nSerialize this message to bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses the encrypted part of the message from inside the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns if this is a <code>relay</code> addr.\nReports whether p looks like it’s a packet containing an …\nWhat the peer believes its endpoints are.\nAllegedly the ping sender’s wireguard public key. It …\nThe observed address off the ping sender.\nReturns the <code>Some(Url)</code> if it is a relay addr.\nIf <code>p</code> looks like a disco message it returns the slice of <code>p</code> …\nRandom client-generated per-ping transaction ID.\nA discovery service that combines multiple discovery …\nNode discovery for <code>super::Endpoint</code>.\nThe results returned from <code>Discovery::resolve</code>.\nA wrapper around a tokio task which runs a node discovery.\nMaximum duration since the last control or data message …\nName used for logging when new node addresses are added …\nAdds a <code>Discovery</code> service.\nThe address info for the node being resolved.\nCancels the discovery task.\nDNS node discovery for iroh-net\nCreates an empty <code>ConcurrentDiscovery</code>.\nWaits until the discovery task produced at least one …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>ConcurrentDiscovery</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOptional timestamp when this node address info was last …\nA discovery service that uses an mdns-like service to …\nStarts a discovery task after a delay and only if no path …\nWe need discovery if we have no paths to the node, or if …\nA discovery service which publishes and resolves node …\nA static string to identify the discovery source.\nPublishes the given <code>AddrInfo</code> to the discovery mechanism.\nResolves the <code>AddrInfo</code> for the given <code>NodeId</code>.\nStarts a discovery task.\nDNS node discovery\nThe n0 testing DNS node origin, for production.\nThe n0 testing DNS node origin, for testing.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new DNS discovery which uses the …\nCreate a new DNS discovery.\nHow long we will wait before we stop sending discovery …\nDiscovery using <code>swarm-discovery</code>, a variation on mdns\nThe n0 local swarm node discovery name\nProvenance string\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>LocalSwarmDiscovery</code> Service.\nDefault TTL for the records in the pkarr signed packet. …\nInterval in which we will republish our node info even if …\nThe pkarr relay run by n0, for production.\nThe pkarr relay run by n0, for testing.\nPublish node info to a pkarr relay.\nA pkarr client to publish <code>pkarr::SignedPacket</code>s to a pkarr …\nResolve node info using a pkarr relay.\nPublish node info to a pkarr relay.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a pkarr publisher which uses the …\nCreate a pkarr resolver which uses the …\nCreate a new config with a secret key and a pkarr relay …\nCreate a new config with a pkarr relay URL.\nCreate a new client.\nPublish a <code>SignedPacket</code>\nResolve a <code>SignedPacket</code>\nPublish <code>AddrInfo</code> about this node to a pkarr relay.\nCreate a new <code>PkarrPublisher</code> with a custom time-to-live …\nThe DNS resolver type used throughout <code>iroh-net</code>.\nHelper enum to give a unified type to the iterators of …\nExtension trait to <code>DnsResolver</code>.\nDeprecated IPv6 site-local anycast addresses still …\nGet resolver to query MX records.\nGet a reference to the default DNS resolver.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by DNS name.\nLooks up node info by DNS name.\nLooks up node info by DNS name in a staggered fashion.\nLooks up node info by DNS name in a staggered fashion.\nPerform an ipv4 lookup with a timeout.\nRace an ipv4 and ipv6 lookup with a timeout.\nResolve IPv4 and IPv6 in parallel.\nRace an ipv4 and ipv6 lookup with a timeout in a staggered …\nRace an ipv4 and ipv6 lookup with a timeout in a staggered …\nPerform an ipv4 lookup with a timeout in a staggered …\nPerform an ipv4 lookup with a timeout in a staggered …\nPerform an ipv6 lookup with a timeout.\nPerform an ipv6 lookup with a timeout in a staggered …\nPerform an ipv6 lookup with a timeout in a staggered …\nSupport for handling DNS resource records for dialing by …\nGet the DNS resolver used within iroh-net.\nStaggers calls to the future F with the given delays.\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nDirect address.\nThe DNS name for the iroh TXT record.\nThe attributes supported by iroh for <code>IROH_TXT_NAME</code> DNS …\nInformation about the iroh node contained in an …\nURL of home relay.\nAttributes parsed from <code>IROH_TXT_NAME</code> TXT records.\nReturns the parsed attributes.\nAny direct addresses.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>NodeInfo</code> from a set of DNS records.\nParses a set of DNS resource records.\nCreates <code>TxtAttrs</code> from a node id and an iterator of …\nParses a <code>NodeInfo</code> from a <code>pkarr::SignedPacket</code>.\nParses a <code>pkarr::SignedPacket</code>.\nCreates <code>TxtAttrs</code> from a node id and an iterator of “…\nParses a <code>NodeId</code> from [<code>z-base-32</code>] encoding.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLooks up attributes by <code>NodeId</code> and origin domain.\nLooks up attributes by DNS name.\nCreates a new <code>NodeInfo</code> from its parts.\nReturns the node id.\nThe <code>NodeId</code>.\nParses a <code>NodeId</code> from iroh DNS name.\nThe advertised home relay server.\nConverts into a <code>hickory_proto::rr::Record</code> DNS record.\nConverts to a list of <code>hickory_proto::rr::Record</code> resource …\nCreates a <code>pkarr::SignedPacket</code>.\nCreates a <code>pkarr::SignedPacket</code>\nEncodes a <code>NodeId</code> in [<code>z-base-32</code>] encoding.\nFuture produced by <code>Endpoint::accept</code>.\nNetwork paths to contact an iroh-net node.\nThe peer closed the connection\nBuilder for <code>Endpoint</code>.\nWe received a CallMeMaybe.\nIn-progress connection attempt future\nA QUIC connection.\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nDetails about an iroh node which is known to this node.\nThe connection was lost\nThe connection was lost\nThe type of connection we have to the endpoint.\nStream returning <code>ConnectionTypes</code>\nThe type of control message we have received.\nThe delay to fall back to discovery when direct addresses …\nDirect UDP connection\nA <em>direct address</em> on which an iroh-node might be …\nInformation about a direct address.\nThe type of direct address.\nStream returning local endpoints as they change.\nControls an iroh-net node, establishing connections with …\nAttempted an ordered read following an unordered read\nA locally bound socket address.\nThe local application closed the connection\nThe largest representable value\nThe largest encoded value length\nBoth a UDP and a relay connection are used.\nNetwork-level addressing information for an iroh-net node.\nWe have no verified connection to this PublicKey\nWe received a Ping from the node.\nWe received a Pong from the node.\nAn address assigned by the router using port mapping.\nErrors that arise from reading from a stream.\nA stream that can only be used to receive data\nRelay connection over relay\nThe peer abandoned transmitting data on this stream\nThe peer is unable to continue processing this connection, …\nA stream that can only be used to send data\nConfiguration for a <code>quinn::Endpoint</code> that cannot be changed …\nThe peer is no longer accepting data on this stream\nPublic internet address discovered via STUN.\nHard NAT: STUN’ed IPv4 address + local fixed port.\nCommunication with the peer has lapsed for longer than the …\nParameters governing the core QUIC state machine\nThe peer violated the QUIC specification as understood by …\nNot yet determined..\nThe stream has already been stopped, finished, or reset\nThe stream has already been finished or reset\nAn integer less than 2^62\nThe peer doesn’t implement any supported version\nErrors that arise from writing to a stream\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nAccepts an incoming connection on the endpoint.\nAccept the next incoming bidirectional stream\nAccept the next incoming uni-directional stream\nInforms this <code>Endpoint</code> about addresses of the iroh-net node.\nInforms this <code>Endpoint</code> about addresses of the iroh-net …\nThe address reported.\nThe address.\nList of addresses at which this node might be reachable, …\nWhether the implementation is permitted to set the spin …\nExtracts the ALPN protocol from the peer’s handshake …\nSets the ALPN protocols that this endpoint will accept on …\nBinds the magic endpoint on the specified socket address.\nCreates a quinn endpoint backed by a magicsock.\nReturns the local socket addresses on which the underlying …\nReturns the builder for an <code>Endpoint</code>, with a production …\nClose the connection immediately.\nCloses the QUIC endpoint and the magic socket.\nIf the connection is closed, the reason why.\nWait for the connection to be closed for any reason\nMaximum number of simultaneous connections to accept.\nHow to construct new <code>congestion::Controller</code>s\nCurrent state of the congestion control algorithm, for …\nThe type of connection we have to the node, either direct …\nReturns a stream that reports connection type changes for …\nConnects to a remote <code>Endpoint</code>.\nConnects to a remote endpoint, using just the nodes’s …\nReturns connection information about a specific node.\nReturns information on all the nodes we have connection …\nCreate a <code>quinn::ServerConfig</code> with the specified ALPN …\nMaximum quantity of out-of-order crypto layer data to …\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nBytes available in the outgoing datagram buffer\nReturns the direct addresses of this <code>Endpoint</code>.\nSocket addresses where the peer might be reached directly.\nOptionally sets a discovery mechanism for this endpoint.\nReturns the discovery mechanism, if configured.\nOptionally sets a custom DNS resolver to use for this …\nReturns the DNS resolver used in this <code>Endpoint</code>.\nWhether to use “Generic Segmentation Offload” to …\nDerive keying material from this connection’s TLS …\nShut down the send stream gracefully.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nReturn the quic mapped address for this <code>node_id</code> and …\nExtract the <code>PublicKey</code> from the peer’s TLS certificate.\nParameters negotiated during the handshake\nParameters negotiated during the handshake\nReturns <code>true</code> if this info contains either a relay URL or …\nReturns the <code>RelayUrl</code> of the Relay server used as home …\nGet the identity of this stream\nGet the identity of this stream\nThe id in the node_map\nAddressing information to connect to <code>Self::node_id</code>.\nThe initial value to be used as the maximum UDP payload …\nThe RTT used before an RTT sample is taken\nSkip verification of SSL certificates from relay servers\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a 0-RTT or 0.5-RTT connection at the cost of …\nExtract the integer value\nCheck if this stream has been opened during 0-RTT.\nCheck if we are being executed in a CGI context.\nPeriod of inactivity before sending a keep-alive packet\nEnables saving the TLS pre-master key for connections.\nOptionally set a list of known nodes.\nWhen was this connection last alive, if ever.\nGet the duration since the last activity we received from …\nLast control message received by this node.\nHow long ago was the last payload message for this node.\nGet the duration since the last activity we received from …\nDuration since the last time this node was used.\nThe latency to the address, if any.\nThe latency of the <code>conn_type</code>.\nThe local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nCreates a <code>quinn::ServerConfig</code> with the given secret key …\nMaximum number of incoming bidirectional streams that may …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nCompute the maximum size of datagrams that may be passed …\nMaximum duration of inactivity to accept before timing out …\nMaximum number of tail loss probes before an RTO fires.\nThe maximum UDP payload size guaranteed to be supported by …\nSpecifies the MTU discovery config (see <code>MtuDiscoveryConfig</code> …\nNotifies the system of potential network changes.\nReturns the current <code>NodeAddr</code> for this endpoint.\nReturns the node id of this endpoint.\nThe node’s identifier.\nThe public key of the endpoint.\nList of known nodes. See <code>Builder::known_nodes</code>.\nInitiate a new outgoing bidirectional stream.\nInitiate a new outgoing unidirectional stream.\nMaximum reordering in packet number space before FACK …\nCryptographic identity of the peer\nNumber of consecutive PTOs after which network is …\nGet the priority of the send stream\nSets the proxy url from the environment, in this order:\nSets an explicit proxy url to proxy all HTTP(S) traffic …\nRead a proxy url from the environment, in this order\nRead data contiguously from the stream.\nRead the next segment of data\nRead the next segments of data\nReceive an application datagram\nRead an exact number of bytes contiguously from the stream.\nConvenience method to read all remaining data into a buffer\nMaximum number of bytes the peer may transmit across all …\nSets the relay servers to assist in establishing …\nThe node’s home relay url.\nrelay server information, if available.\nThe peer’s UDP address\nThe peer’s UDP address.\nClose the send stream immediately.\nCurrent best estimate of this connection’s latency …\nActor which coordinates the congestion controller for the …\nSets a secret key to authenticate with other peers.\nReturns the secret_key of this endpoint.\nTransmit <code>data</code> as an unreliable, unordered application …\nMaximum number of bytes to transmit to a peer without …\nSets the list of accepted ALPN protocols.\nModify the number of remotely initiated bidirectional …\nModify the number of remotely initiated unidirectional …\nSet the priority of the send stream\nSee <code>proto::TransportConfig::receive_window()</code>\nA stable identifier for this connection\nReturns connection statistics\nStop accepting data\nCompletes if/when the peer stops the stream, yielding the …\nMaximum number of bytes the peer may transmit without …\nMaximum reordering in time space before time based loss …\nSets a custom <code>quinn::TransportConfig</code> for this endpoint.\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nTry send a message to the rtt-actor.\nThe origin of this direct address.\nWatches for changes to the home relay.\nReturns a weak reference to the inner connection struct.\nWrite bytes to the stream\nConvenience method to write an entire buffer to the stream\nConvenience method to write an entire list of chunks to …\nConvenience method to write a single chunk in its entirety …\nWrite chunks to the stream\nInforms the <code>RttActor</code> of a new connection is should monitor.\nActor to coordinate congestion controller state with magic …\nMessages to send to the <code>RttActor</code>.\nStream of connection type changes.\nReferences to the connections.\nPerforms cleanup for closed connection.\nPerforms the congestion controller reset for a magic …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandle actor messages.\nHandles the new connection message.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRuns the actor main loop.\nA way to notify the main actor loop to run over.\nPath changes for this connection from the magic socket.\nThe connection.\nFor reporting-only, the Node ID of this connection.\nSize of an encoded Ed25519 signature in bytes.\nError when decoding the base32.\nError when decoding the public key.\nError when deserialising a <code>PublicKey</code> or a <code>SecretKey</code>.\nThe identifier for a node in the (iroh) network.\nThe length of an ed25519 <code>PublicKey</code>, in bytes.\nA public key.\nA secret key.\nShared Secret.\nEd25519 signature.\nGet this public key as a byte array.\nConvert to a base32 string limited to the first 10 bytes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse an Ed25519 signature from a byte slice.\nConstruct a <code>PublicKey</code> from a slice of bytes.\nCreate a secret key from its byte representation.\nParse an Ed25519 signature from its <code>R</code> and <code>s</code> components.\nParse an Ed25519 signature from a byte slice.\nGenerate a new <code>SecretKey</code> with the default randomness …\nGenerate a new <code>SecretKey</code> with a randomness generator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpens the ciphertext, which must have been created using …\nThe public key of this <code>SecretKey</code>.\nBytes for the <code>R</code> component of a signature.\nBytes for the <code>s</code> component of a signature.\nSeals the provided cleartext.\nReturns the shared key for communication between this key …\nSign the given message and return a digital signature\nReturn the inner byte array.\nConvert this to the bytes representing the secret part. …\nSerialise this key to OpenSSH format.\nConvert this signature into a byte vector.\nDeserialise this key from OpenSSH format.\nVerify a signature on a message with this secret key’s …\nCounter to always generate unique addresses for …\nThe Global ID used in our Unique Local Addresses.\nThe Prefix/L of our Unique Local Addresses.\nThe Subnet ID used in our Unique Local Addresses.\nA <em>direct address</em> on which an iroh-node might be …\nThe type of direct address.\nManages currently running direct addr discovery, aka …\nStream returning local endpoints as they change.\nThe discovered direct addresses of this <code>MagicSock</code>.\nHow long we consider a STUN-derived endpoint valid for. …\nContains the error value\nHandle for <code>MagicSock</code>.\nA locally bound socket address.\nIroh connectivity layer.\nMaximum duration to wait for a netcheck report.\nContains information about the host’s network state.\nContains the success value\nContains options for <code>MagicSock::listen</code>.\nSplits a packet into its component items.\nAn address assigned by the router using port mapping.\nThe fake address used by the QUIC layer to address a node.\nContents of a relay message. Use a SmallVec to avoid …\nPublic internet address discovered via STUN.\nHard NAT: STUN’ed IPv4 address + local fixed port.\nNot yet determined..\nAdd addresses for a node to the magic socket’s …\nThe address.\nThe last set of discovered direct addresses.\nChecks if this is probably still the same network as <em>other</em>.\nInitial connection setup.\nCloses the connection.\nTells the relay actor to close stale relay connections.\nClose was called.\nClose is in progress (or done)\nReturns a stream that reports the <code>ConnectionType</code> we have …\nRetrieve connection information about a node in the …\nRetrieve connection information about nodes in the network.\nIndicates the direct addr update state.\nReturns the direct addresses as a stream.\nOur discovered direct addresses.\nThe state for an active DiscoKey.\nReference to optional discovery service\nOptional node discovery mechanism.\nOptional discovery service\nGet a reference to the DNS resolver used in this <code>MagicSock</code>.\nA DNS resolver to use for resolving relay URLs.\nThe DNS resolver to be used in this magicsock.\nReports whether x and y represent the same set of …\nCalled when a direct addr update is done, no matter if it …\nClears the current running state.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a globally unique fake UDP address.\nReturns the <code>SocketAddr</code> which can be used by the QUIC layer …\nIf their router does hairpinning. It reports true even if …\nProcesses an incoming actor message.\nHandles a discovery message.\nHandle a ping message.\nReturns <code>true</code> if we have at least one candidate address …\nWhether we have an existing portmap open (UPnP, PMP, or …\nSkip verification of SSL certificates from relay servers\nSkip verification of SSL certificates from relay servers\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nIf the last netcheck report, reports IPv6 to be available.\nReturns <code>true</code> if an update is currently in progress.\nGet the cached version of the Ipv4 and Ipv6 addrs of the …\nCached version of the Ipv4 and Ipv6 addrs of the current …\nSays whether the host’s NAT mappings vary based on the …\nString representation of the node_id of this node.\nReturns the relay node we are connected to, that has the …\nNearest relay node ID; 0 means none/unknown.\nThe prober that discovers local network conditions, …\nNetcheck client\nThe <code>NetInfo</code> provided in the last call to <code>net_info_func</code>. It…\nCall to notify the system of potential network changes.\nStores wakers, to be called when relay_recv_ch receives …\nCreates a magic <code>MagicSock</code> listening on <code>Options::port</code>.\nCreate a new PacketSplitIter from a packet.\nReturns the next update, if one is set.\nWhether IPv4 UDP is known to be unable to transmit at all. …\nAn optional <code>NodeMap</code>, to restore information about nodes.\nTracks the networkmap node entity for each node discovery …\nWhether the OS supports IPv6 at all, regardless of whether …\nUDP IPv4 socket\nUDP IPv6 socket\nList of CallMeMaybe disco messages that should be sent out …\nWhen set, is an AfterFunc timer that will call …\nReturns a deterministic relay node to connect to. This is …\nNOTE: Receiving on a <code>Self::close</code>d socket will return …\nNOTE: Receiving on a <code>Self::closed</code> socket will return …\nSend a disco message. UDP messages will be polled to send …\nThe port to listen on. Zero means to pick one …\nPreferred port from <code>Options::port</code>; 0 means auto.\nThe NAT-PMP/PCP/UPnP prober/client, for requesting port …\nProbe indicating the presence of port mapping protocols on …\nThis node’s preferred relay server for incoming traffic.\nGet the current proxy configuration.\nProxy configuration.\nProxy\nPublishes our address to a discovery service, if …\nTriggers an address discovery. The provided why string is …\nThe fastest recent time to reach various relay STUN …\nThe <code>RelayMap</code> to use, leave empty to not use a relay server.\nNone (or zero nodes) means relay is disabled.\nUsed for receiving relay messages.\nChannel to send received relay messages on, for processing.\nResets the preferred address for all nodes. This is called …\nTrigger a new run.\nIf running, set to the reason for the currently the update.\nSchedules a new run, either starting it immediately if …\nSecret key for this node.\nKey for this node.\nSend buffer used in <code>poll_send_udp</code>\nSend a disco message. UDP messages will be queued.\nSets the relay node with the best latency.\nUpdates <code>NetInfo.HavePortMap</code> to true.\nCreates a magic <code>MagicSock</code> listening on <code>Options::port</code>.\nSplit a number of transmits into individual packets.\nStores the results of a successful direct addr update.\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nThe origin of this direct address.\nUDP disco (ping) queue\nUpdates our direct addresses.\nRefreshes knowledge about our direct addresses.\nCalls netcheck.\nThe last time the direct addresses were updated, even if …\nIf set, start a new update as soon as the current one is …\nWatch for changes to the home relay.\nWhether ICMPv4 works, <code>None</code> means not checked.\nWhether ICMPv6 works, <code>None</code> means not checked.\nWhether the host has IPv6 internet connectivity.\nWhether the host has UDP internet connectivity.\nEnum of metrics for the module\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe number of direct connections we have made to peers.\nThe number of direct connections we have lost to peers.\nThe number of connections to peers we have added over …\nThe number of connections to peers we have removed over …\nNumber of QUIC datagrams received.\nApplication layer added the node directly.\nStream returning <code>ConnectionTypes</code>\nAn (Ip, Port) pair.\nNumber of nodes that are inactive for which we keep info …\nMap of the <code>NodeState</code> information for all the known nodes.\nIdentifier to look up a <code>NodeState</code> in the <code>NodeMap</code>.\nNode communicated with us first via relay.\nNode was loaded from the fs.\nSource for a new node.\nNode communicated with us first via UDP.\nAdd the contact information for a node.\nAdd the contact information for a node.\nThe <code>BestAddr</code> is the currently active best address for UDP …\nReturns a stream of <code>ConnectionType</code>.\nReturns a stream of <code>ConnectionType</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert a received ping into the node map, and return …\nInserts a new node into the <code>NodeMap</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>NodeMap</code> from a list of <code>NodeAddr</code>s.\nCreate a new <code>NodeMap</code> from a list of <code>NodeAddr</code>s.\nNumber of nodes currently listed.\nNumber of nodes currently listed.\nGet the <code>NodeInfo</code>s for each endpoint\nGet the <code>NodeInfo</code>s for each endpoint\nGets the <code>NodeInfo</code>s for each endpoint\nGet the <code>NodeInfo</code>s for each endpoint\nPrunes direct addresses from nodes that claim to share an …\nPrunes nodes without recent activity so that at most …\nPrunes nodes without recent activity so that at most …\nMarks the node we believe to be at <code>ipp</code> as recently used.\nRemoves a direct address from a node.\nMakes future node lookups by ipp return the same endpoint …\nA <code>SocketAddr</code> with an associated latency.\nHow long we trust a UDP address as the exclusive path …\nUnconditionally clears the best address.\nClears the best address if equal to <code>addr</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReports whether <code>self</code> is a better addr to use than <code>other</code>.\nReset the expiry, if the passed in addr matches the …\nWe received a CallMeMaybe.\nThe type of connection we have to the endpoint.\nThe type of control message we have received.\nThe minimum time between pings to an endpoint. (Except in …\nDirect UDP connection\nInformation about a direct address.\nThe reason why a discovery ping message was sent.\nThe purpose of a ping was to see if a path was valid.\nThe latency at or under which we don’t try to upgrade to …\nHow long since an endpoint path was last alive before it …\nNumber of addresses that are not active that we keep …\nBoth a UDP and a relay connection are used.\nDetails about an iroh node which is known to this node.\nAn iroh node, which we can have connections with.\nWe have no verified connection to this PublicKey\nOptions for creating a new <code>NodeState</code>.\nHow long we wait for a pong reply before assuming it’s …\nState about a particular path to another <code>NodeState</code>.\nWe received a Ping from the node.\nWhen a ping was received and no direct connection exists …\nIndicating an <code>NodeState</code> has handled a ping.\nWe received a Pong from the node.\nRelay connection over relay\nInformation about a relay URL.\nHow long since the last activity we try to keep an …\nHow long until we send a stayin alive ping\nWhether to send a call-me-maybe message after sending …\nPing to ensure the current route is still valid.\nHow often we try to upgrade to a better patheven if we …\nIs this endpoint currently active (sending data)?\nThe address reported.\nReturns the address(es) that should be used for sending …\nList of addresses at which this node might be reachable, …\nFixup best_adrr from candidates.\nBest non-relay path, i.e. a UDP address.\nIf non-zero, is the time this endpoint was advertised last …\nThe type of connection we have to the node, either direct, …\nThe type of connection we have to the node, either direct …\nState for each of this node’s direct paths.\nGet the direct addresses for this endpoint.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe pong’s src (usually same as endpoint map key).\nReturns the addresses on which a payload should be sent …\nHandles a DISCO CallMeMaybe discovery message.\nHandle a received Disco Ping.\nHandles a Pong message (a reply to an earlier ping).\nThe ID used as index in the <code>NodeMap</code>.\nThe id in the node_map\nReturns info about this endpoint\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if this <code>Endpoint</code> is currently actively being used.\nCheck whether this path is considered active.\nReports the last instant this path was considered alive.\nWhen was this connection last alive, if ever.\nHow long ago was the relay url last used.\nLast time we sent a call-me-maybe.\nLast control message received by this node.\nThe last time we pinged all endpoints.\nIf non-zero, means that this was an endpoint that we …\nReturns the instant the last incoming ping was received.\nHow long ago was the last payload message for this node.\nWhen was this endpoint last used to transmit payload data …\nThe last (outgoing) ping time.\nLast time this node was used.\nDuration since the last time this node was used.\nReturns the latency from the most recent pong, if …\nThe latency to the address, if any.\nLatency of the relay url.\nThe latency of the <code>conn_type</code>.\nWhether the sender path should also be pinged.\nThe global identifier for this endpoint.\nThe node for which this path exists.\nThe public key of the endpoint.\nCalled when connectivity changes enough that we should …\nThe path this applies for.\nRecord the fact that a ping has been sent out.\nCleanup the expired ping for the passed in txid.\nWhen we received the pong.\nWhat they reported they heard.\nPrune inactive paths.\nThe UDP address used on the QUIC-layer to address this …\nMarks this endpoint as having received a UDP payload …\nReturns the most recent pong if available.\nLast <code>PongReply</code> received.\nReturns the relay url of this endpoint\nThe url of relay node that we can relay over to …\nThe relay url\nrelay server information, if available.\nRemoves a direct address for this node.\nClears all the endpoint’s p2p state, reverting it to a …\nWhat this ping did to the <code>NodeState</code>.\nSend a DISCO call-me-maybe message to the peer.\nSend DISCO Pings to all the paths of this node.\nSend a heartbeat to the node to keep the connection alive, …\nWhether we need to send another call-me-maybe to the …\nContains fields for an active relay connection.\nCombines blobs into packets of at most MAX_PACKET_SIZE.\nHow often <code>clean_stale_relay</code> runs when there are …\nHow long a non-home relay connection needs to be idle …\nrelay Url -&gt; connection to the node\npacket data\nCloses the relay connection to the provided <code>url</code> and starts …\nConnect to the given relay node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nThe time of the last request for its write channel …\nCloses the relay connections not originating from a local …\nCreate a new new PacketizeIter from something that can be …\nThe set of senders we know are present on this connection, …\nContains optional alternate routes to use as an …\nReturns <code>true</code>if the message was sent successfully.\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nA timer that works similar to golangs <code>Timer</code>.\nAbort the timer.\nWill trigger the execution of <code>f</code> after time <code>d</code> once.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA UDP socket implementing Quinn’s <code>AsyncUdpSocket</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEnum of metrics for the module\nThe number of direct connections we have made to peers.\nThe number of direct connections we have lost to peers.\nThe number of connections to peers we have added over …\nThe number of connections to peers we have removed over …\nNumber of QUIC datagrams received.\nIp family selection between Ipv4 and Ipv6.\nWrapper around a tokio UDP socket that handles the fact …\nIpv4\nIpv6\nContains helpers for looking up system network interfaces.\nIP address related utilities.\nMonitoring of networking interfaces and route changes.\nThe details about a default route.\nLikely IPs of the residentla router, and the ip address of …\nRepresents a network interface.\nStructure of an IP network, either IPv4 or IPv6.\nStructure of IPv4 Network\nStructure of IPv6 Network\nIntended to store the state of the machine’s network …\nStructure of IPv4 Network.\nStructure of IPv6 Network.\nThe IP address of this structure.\nIPv4 Address\nIPv6 Address\nA list of all ip addresses of this interface.\nReturns the broadcast address.\nReturns the broadcast address.\nChecks if the IP Address is in the network.\nChecks if the IP Address is in the network.\nLike <code>DefaultRoutDetails::new</code> but only returns the …\nThe interface name for the machine’s default route.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIp of the router.\nWhether the machine has some non-localhost, non-link-local …\nWhether this machine has an IPv6 Global or Unique Local …\nReturns the host mask.\nReturns the host mask.\nThe HTTP proxy to use, if any.\nThe interface name. It’s like “eth0” (Linux), “…\nMaps from an interface name interface.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ninstead of Wifi. This field is not populated by <code>get_state</code>.\nIs this interface up?\nReports whether ip is a usable IPv4 address which should …\nReports whether ip is a usable IPv6 address which should …\nLinux-specific network interfaces implementations.\nReturns the maximum valid prefix length.\nReturns the maximum valid prefix length.\nOur local Ip if known.\nThe name of the interface.\nReturns the network mask.\nReturns the network mask.\nNetwork Mask\nNetwork Mask\nReturns the network address.\nReturns the network address.\nConstruct a new Ipv4Net instance from IPv4 Address and …\nConstruct a new Ipv6Net instance from IPv6 Address and …\nReturns the state of all the current machine’s network …\nReads the default route from the current system and …\nReturns the likely IP of the residential router, which …\nConstruct a new Ipv4Net instance from IPv4 Address and …\nConstruct a new Ipv6Net instance from IPv6 Address and …\nThe URL to the Proxy Autoconfig URL, if applicable.\nPrefix Length\nPrefix Length\nReturns the <code>(name, index)</code> of the interface for the default …\nList of machine’s IP addresses.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReports whether ip is a private address, according to RFC …\nReturns true if the address is a unicast address with …\nLoopback addresses.\nReturns the machine’s IP addresses. If there are no …\nRegular addresses.\nConverts IPv4-mappend IPv6 addresses to IPv4.\nIp family selection between Ipv4 and Ipv6.\nIpv4\nIpv6\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the matching localhost address.\nReturns the matching default address.\nToken to remove a callback\nMonitors networking interface and route changes.\nReturns the argument unchanged.\nTask handle for the monitor task.\nCalls <code>U::from(self)</code>.\nPotential change detected outside\nCreate a new monitor.\nSubscribe to network changes.\nUnsubscribe a callback from network changes, using the …\nCallbacks that get notified about changes.\nToken to remove a callback\nA change was detected.\nThe message sent by the OS specific monitors.\nHow often we execute a check for big jumps in wall time.\nCallback registry.\nReports whether wall time jumped more than 150% of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLatest known interface state.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether <code>a</code> and <code>b</code> are equal after ignoring …\nOS specific monitor.\nLatest observed wall time.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUDP socket read/write buffer size (7MB). The value of 7MB …\nWrapper around a tokio UDP socket that handles the fact …\nBind to the given port and listen on all interfaces.\nBind to any provided <code>SocketAddr</code>. Does not prepare for …\nBind to the given port only on localhost.\nBind only Ipv4 on localhost.\nBind only Ipv6 on localhost.\nBind only Ipv4 on any interface.\nBind only Ipv6 on any interface.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe netcheck actor.\nSender to the <code>Actor</code>.\nClient to run netchecks.\nThe maximum latency of all nodes, if none are found yet.\nA probe wants to register an in-flight STUN request.\nMessages to send to the <code>Actor</code>.\nEnum of metrics for the module\nLatencies per relay node.\nA netcheck report.\nThe <code>reportgen</code> actor failed to produce a report.\nA report produced by the <code>reportgen</code> actor.\nState the netcheck actor needs for an in-progress report …\nRun a netcheck.\nAn incoming STUN packet to parse.\nEnsures the actor is terminated when the client is dropped.\nDrop guard to optionally kill workers started by netcheck …\nThe handle of the <code>reportgen</code> actor, cancels the actor on …\nAdds <code>r</code> to the set of recent Reports and mutates …\nReturns the channel to send messages to the actor.\nChannel to send message to the <code>Actor</code>.\nAttempts to bind a local socket to send STUN packets from.\nCaptivePortal is set when we think there’s a captive …\nThe <code>reportgen</code> actor currently generating a report.\nThe DNS resolver to use for probes that need to perform …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRuns a netcheck, returning the report.\nGet report with channel\nip:port of global IPv4\n<code>[ip]:port</code> of global IPv6\nWhether the router supports communicating between two …\nHandles <code>Message::InFlightStun</code>.\nStarts a check run as requested by the <code>Message::RunCheck</code> …\nHandles <code>Message::StunPacket</code>.\nAn ICMPv4 round trip completed, <code>None</code> if not checked.\nAn ICMPv6 round trip completed, <code>None</code> if not checked.\nInformation about the currently in-flight STUN requests.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn IPv4 STUN round trip completed.\nan IPv4 packet was able to be sent\nAn IPv6 STUN round trip completed.\nAn IPv6 packet was able to be sent\nReturns an iterator over all the relays and their …\nMost recent report.\nTime of last full (non-incremental) report.\nWhether STUN results depend on which STUN server you’re …\nWhether STUN results depend on which STUN server you’re …\nReturns the maximum latency for all relays.\nMerges another <code>RelayLatencies</code> into this one.\nCreates a new netcheck client.\nCreates a new actor.\nDo a full relay scan, even if last is <code>Some</code>.\nTest if IPv6 works at all, or if it’s been hard disabled …\ncould bind a socket to ::1\nThe port mapper client, if those are requested.\nProbe indicating the presence of port mapping protocols on …\n<code>None</code> for unknown\nSome previous reports.\nPass a received STUN packet to the netchecker.\nActor messages channel.\nReceive STUN response from a UDP socket, pass it to the …\nkeyed by relay Url\nkeyed by relay Url\nkeyed by relay Url\nWhere to send the completed report.\nThe reportgen actor is responsible for generating a single …\nA collection of previously generated reports.\nRun the actor.\nResponse to send STUN results: latency of STUN response …\nThe sender side of the messages channel.\nThe time the STUN probe was sent.\nThe STUN transaction ID.\nA UDP STUN round trip completed.\nUpdates a relay’s latency, if it is faster than before.\nThe address this was claimed to be received from.\nThe raw UDP payload.\nThe relay configuration.\nChannel to receive the response.\nSocket to send IPv4 STUN probes from.\nSocket to send IPv6 STUN probes from.\nEnum of metrics for the module\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAbort all remaining probes.\nAbort the current set.\nThe reportstate actor.\nThe address of the reportstate <code>Actor</code>.\nHow long to await for a captive-portal result.\nTimeout for captive portal checks\nHolds the state for a single invocation of …\nDelay used to perform staggered dns queries.\nContinue the other probes in the set.\nSet the hairpinning availability in the report.\nMessages to send to the reportstate <code>Actor</code>.\nThe maximum amount of time netcheck will spend gathering a …\nTasks on which the reportgen <code>Actor</code> is still waiting.\nThe total time we wait for all the probes.\nErrors for <code>run_probe</code>.\nThe success result of <code>run_probe</code>.\nCheck whether executing a probe would still help.\nThe discovered public address.\nReports whether or not we think the system is behind a …\nThe DNS resolver to use for probes that need to resolve …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the IP address to use to communicate to this relay …\nActor to run hairpinning check.\nThe hairping actor.\nStops further probes.\nHandles an actor message.\nWhether we can send ICMPv4 packets, <code>None</code> if not checked.\nWhether we can send ICMPv6 packets, <code>None</code> if not checked.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether we can send IPv4 UDP packets.\nWhether we can send IPv6 UDP packets.\nThe previous report, if it exists.\nThe latency to the relay node.\nThe receiver of the message channel.\nThe sender of the message channel, so we can give out <code>Addr</code>.\nThe address of the netcheck actor.\nCreates a new actor generating a single report.\nWhich tasks the <code>Actor</code> is still waiting on.\nThe portmapper client, if there is one.\nCreates the future which will perform the captive portal …\nCreates the future which will perform the portmapper task.\nThe probe that generated this report.\nWhether running this probe would still improve our report.\nThe relay probes.\nThe relay configuration.\nThe report being built.\nRuns an ICMP IPv4 or IPv6 probe.\nRuns the main reportgen actor logic.\nExecutes a particular <code>Probe</code>, including using a delayed …\nRun a STUN IPv4 or IPv6 probe.\nBlocking send to the actor, to be used from a non-actor …\nPrepares the future which will run all the probes as per …\nSocket to send IPv4 STUN requests from.\nSocket so send IPv6 STUN requests from.\nUpdates a netcheck <code>Report</code> with a new <code>ProbeReport</code>.\nHandle to the hairpin actor.\nThe amount of time we wait for a hairpinned packet to come …\nPerforms the hairpin check.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if we have started a hairpin check before.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStarts the hairpin check.\nThe extra time to add to retransmits if a previous report …\nThe retransmit interval used when a previous report exists …\nThe retransmit interval used when netcheck first runs.\nHTTPS\nICMP IPv4\nICMP IPv6\nThe number of fastest relays to periodically re-query …\nA probe plan.\nThe protocol used to time a node’s latency.\nA probe set is a sequence of similar <code>Probe</code>s with delays …\nSTUN IPv4\nSTUN IPv6\nAdds a <code>ProbeSet</code> if it contains probes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an initial probe plan.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over the <code>ProbeSet</code>s in this plan.\nReturns the delay of the last probe in the probe plan.\nThe probes in the set.\nThe <code>ProbeProto</code> all the probes in this set have.\nSorts the nodes in the <code>RelayMap</code> from fastest to slowest.\nCreates a follow up probe plan using a previous netcheck …\nWhen the probe is started, relative to the time that …\nThe relay server to send this probe to.\nCould not create client, probably bind error.\nCould not send ping.\nWhether this error was because we couldn’t create a …\nAllows sending ICMP echo requests to a host in order to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLazily create the ping client.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new Pinger.\nSend a ping request with associated data, returning the …\nIf a port mapping service has been seen within the last …\nPort mapping client.\nConfigures which port mapping protocols are enabled in the …\nContains the error value\nEnum of metrics for the module\nContains the success value\nPort mapping protocol information obtained during a probe.\nRequest to probe the port mapping protocols.\nOutput of a port mapping probe.\nAttempt to get a mapping if the local port is set but …\nCapacity of the channel to communicate with the …\nA port mapping client.\nIf a port mapping service has not been seen within the …\nRequest to update the local port.\nA handle to the service that will cancel the spawned task …\nIndicates if all port mapping protocols are available.\nHolds the current mapping value and ensures that any …\nCurrently active mapping.\nDeactivate port mapping.\nBy default all port mapping protocols are enabled.\nAn empty probe set to <code>now</code>.\nWhether PMP is enabled.\nWhether PCP is enabled.\nWhether UPnP is enabled.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new probe based on a previous output.\nLast updated probe.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nClears the current mapping and releases it.\nGets the local ip and gateway address for port mapping.\nLast time NAT-PMP was seen.\nLast time PCP was seen.\nWhen was the probe last updated.\nThe last <code>upnp::Gateway</code> and when was it last seen.\nLocal port to map.\nA port mapping created with one of the supported protocols.\nTask attempting to get a port mapping.\nDefinitions and utilities to interact with a NAT-PMP …\nIf PMP can be considered available.\nCreate a new port mapping client.\nReturns a <code>ProbeOutput</code> indicating which services can be …\nDefinitions and utilities to interact with a PCP server.\nIf PCP can be considered available.\nA watcher over the most recent external address obtained …\nRequest a probe to the port mapping protocols.\nHandles a probe request.\nTask probing the necessary protocols.\nTry to get a mapping for the last local port if there isn…\nChannel over which the service is informed of messages.\nChannel used to communicate with the port mapping service.\nUpdates a probe with the <code>Some</code> values of another probe that …\nUpdate the local port.\nUpdates the local port of the port mapping service.\nIf UPnP can be considered available.\nWatch the external address for changes in the mappings.\nSender side to communicate the result of the probe.\nModels the lifetime of an active mapping.\nHolds the current mapping value and ensures that any …\nEvents in the lifetime of the mapping.\nMapping has expired.\nThis is an implementation detail to facilitate testing.\nOn this event, the mapping is halfway through its lifetime …\nA <code>watch::Sender</code> that keeps the latest external address for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHalf the lifetime of a mapping. This is used to calculate …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nActive port mapping.\nCreates a new <code>CurrentMapping</code> and returns the watcher over …\nUpdates the mapping, informing of any changes to the …\nWaker to ensure this is polled when needed.\nA port mapping created with one of the supported protocols.\nA NAT-PMP mapping.\nA PCP mapping.\nA UPnP mapping.\nReturns the argument unchanged.\nHalf the lifetime of a mapping. This is used to calculate …\nCalls <code>U::from(self)</code>.\nCreate a new NAT-PMP mapping.\nCreate a new PCP mapping.\nCreate a new UPnP mapping.\nRelease the mapping.\nEnum of metrics for the module\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRecommended lifetime is 2 hours. See RFC 6886 Requesting a …\nA mapping successfully registered with a NAT-PMP server.\nTimeout to receive a response from a NAT-PMP server.\nExternal address of the mapping.\nExternal port of the mapping.\nReturns the argument unchanged.\nGateway address used to registered this mapping.\nCalls <code>U::from(self)</code>.\nAllowed time for this mapping as informed by the server.\nLocal ip used to create this mapping.\nLocal port used to create this mapping.\nAttempt to register a new mapping with the NAT-PMP server …\nProbes the local gateway for NAT-PMP support.\nDefinitions and utilities to interact with a NAT-PMP …\nReleases the mapping.\nDetermine the external address of the gateway.\nGet a UDP Mapping.\nNAT-PMP version\nOpcode accepted by a NAT-PMP server.\nPort to use when acting as a server. This is the one we …\nNat Version according to RFC 6886 Transition to Port …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA NAT-PCP request encoding and decoding.\nA NAT-PMP response encoding and decoding.\nRequest to determine the gateway’s external address.\nProtocol for which a port mapping is requested.\nRequest to register a mapping with the NAT-PCP server.\nA NAT-PCP Request.\nUDP mapping.\nEncode this <code>Request</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPreferred external port.\nRequested lifetime in seconds for the mapping.\nLocal port to map.\nProtocol to use for this mapping.\nErrors that can occur when decoding a <code>Response</code> from a …\nThe received opcode is not recognized.\nThe received result code is not recognized.\nThe received version is not recognized.\nMinimum size of an encoded <code>Response</code> sent by a server to …\nMinimum size of an encoded <code>Response</code> sent by a server to …\nRequest is too short or is otherwise malformed.\nNetfork failures, e.g. NAT device itself has not obtained …\nReceived an error code indicating the server experienced a …\nThe <code>Response::RESPONSE_INDICATOR</code> is not present.\nFunctionality is supported but not allowerd: e.g. box …\nReceived an error code indicating the operation is …\nNAT-PMP server cannot create any more mappings at this …\nReceived an error code indicating the server cannot create …\nResponse to a <code>Opcode::MapUdp</code> request.\nResponse to a <code>Opcode::DetermineExternalAddress</code> request.\nIndicator ORd into the <code>Opcode</code> to indicate a response …\nA NAT-PMP successful Response/Notification.\nResult code obtained in a NAT-PMP response.\nA successful response.\nOpcode is not supported by the server.\nReceived an error code indicating the Opcode is not …\nThe sent version is not supported by the NAT-PMP server.\nReceived an error code indicating the server does not …\nDecode a response.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEpoch time of the server.\nExternal port registered for this mapping.\nLifetime in seconds that can be assumed by this mapping.\nLocal port for which the mapping was created.\nProtocol for which the mapping was requested.\nUse the recommended port mapping lifetime for PMP, which …\nA mapping successfully registered with a PCP server.\nTimeout to receive a response from a PCP server.\nExternal address of the mapping.\nExternal port of the mapping.\nReturns the argument unchanged.\nGateway address used to registered this mapping.\nCalls <code>U::from(self)</code>.\nAllowed time for this mapping as informed by the server.\nLocal ip used to create this mapping.\nLocal port used to create this mapping.\nAttempt to registered a new mapping with the PCP server on …\nThe nonce of the mapping, used for modifications with the …\nProbes the local gateway for PCP support.\nDefinitions and utilities to interact with a PCP server.\nAnnounce Opcode.\nMap Opcode,\nOpcode as defined in RFC 6887 IANA Considerations\nPCP Version according to RFC 6887 Version Negotiation\nPort to use when acting as a server. This is the one we …\nNAT-PMP/PCP Version\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncoding and decoding of the data associated with an <code>Opcode</code>…\nA PCP request encoding and decoding.\nA PCP response encoding and decoding.\nData for an <code>Opcode::Announce</code> request.\nSize of the opcode-specific data of a <code>Opcode::Map</code> request.\nGeneric error returned when decoding <code>OpcodeData</code> fails.\n<code>OpcodeData</code> associated to a <code>Opcode::Map</code>.\nData for an <code>Opcode::Map</code> request.\nProtocol for which a port mapping is requested.\nData associated to an <code>Opcode</code>\nDecode the <code>OpcodeData</code> expected for a given <code>Opcode</code>.\nDecode a <code>MapData</code>.\nEncode this <code>MapData</code>.\nEncode this <code>OpcodeData</code> into the buffer.\nExact size an encoded <code>OpcodeData</code> will have.\nExternal ip of the mapping.\nExternal port of the mapping.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLocal port for the mapping.\nNonce of the request. Used to verify responses in the …\nGet the associated <code>Opcode</code>.\nProtocol for which the mapping is being requested.\nSize of a <code>Request</code> sent by this client, in bytes.\nA PCP Request.\nCreate an announce request.\nIP Address of the client.\nEncode this <code>Request</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRequested lifetime in seconds.\nCreate a mapping request.\nData associated to the <code>super::Opcode</code> in this request.\n<code>Version</code> to use in this request.\nThe source IP address of the request packet does not match …\nThe suggested external port and/or external address cannot …\nErrors that can occur when decoding a <code>Response</code> from a …\nAn error code. See <code>ErrorCode</code>.\nResultCode in a <code>Response</code>, when said code is an error. …\nThe PCP server was not able to create the filters in this …\nThe received opcode is not recognized.\nThe received opcode data could not be decoded.\nThe received result code is not recognized.\nThe received version is not recognized.\nMax size of a PCP packet as indicated in RFC 6887 Common …\nMinimum size of an encoded <code>Response</code> sent by a server to …\nRequest is too short or is otherwise malformed.\nMalformed option (e.g., appears too many times, invalid …\nThe request could not be successfully parsed.\nThe PCP server or the device it controls is experiencing a …\nRequest is well-formed and valid, but the server has …\nThe <code>Response::RESPONSE_INDICATOR</code> is not present.\nThe requested operation is disabled for this PCP client, …\nIndicator ORd into the <code>Opcode</code> to indicate a response …\nA PCP successful Response/Notification.\nResult code of a PCP response.\nResult code indicating a successful response.\nA success result code. See <code>SuccessCode</code>.\nResultCode in a <code>Response</code> when it’s successful.\nUnsupported Opcode.\nUnsupported option. This error only occurs if the option …\nUnsupported transport protocol, e.g., SCTP in a NAT that …\nThe version number at the start of the PCP Request header …\nThis attempt to create a new mapping would exceed this …\nData of the resoponse.\nDecode a response.\nEpoch time of the server.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLifetime in seconds that can be assumed by this response.\nTailscale uses the recommended port mapping lifetime for …\nName with which we register the mapping in the router.\nSeconds we ask the router to maintain the port mapping. 0 …\nMaximum duration a UPnP search can take before timing out.\nSocket address of the gateway\nControl schema for all actions\nUrl to get schema data from\nControl url of the device\nReturns the external gateway ip and port that can be used …\nThe external address obtained by this mapping.\nExternal port obtained by this mapping.\nReturns the argument unchanged.\nThe internet Gateway device (router) used to create this …\nCalls <code>U::from(self)</code>.\nSearches for UPnP gateways.\nExecutor provider\nReleases the mapping.\nRoot url of the device\nHandle incoming connections to the Server.\nUse a custom relay map.\nUse the default relay map, with production relay servers …\nDisable relay servers completely.\nA one-way message from server to client, declaring the …\nA one-way empty message from server to client, just to …\nThe maximum size of a packet sent over relay. (This only …\nWhether or not the underlying <code>tokio::net::TcpStream</code> is …\nMetrics tracked for the relay server\nIndicates that the client identified by the underlying …\nRequest from a client or server to reply to the other side …\nA plain non-Tls <code>tokio::net::TcpStream</code>\nReply to a <code>ReceivedMessage::Ping</code> from a client or server …\nThe type of message received by the <code>Client</code> from the …\nRepresents an incoming packet.\nA relay Client. Cheaply clonable. Call <code>close</code> to shutdown …\nConfiguration of all the relay servers that can be used.\nConfiguration options for the relay servers of the magic …\nInformation on a specific relay server.\nA URL identifying a relay server.\nA relay server.\nSent by the server upon first connect.\nA one-way message from server to client, advertising that …\nUse the staging relay servers from n0.\nA Tls wrapped <code>tokio::net::TcpStream</code>\nNumber of connections we have accepted\nBytes received from a <code>FrameType::SendPacket</code>\nBytes sent from a <code>FrameType::SendPacket</code>\nDone token, forces a hard shutdown. To gracefully …\nbased on tailscale/derp/derp_client.go\nbased on tailscale/derp/derp_server.go\nWhen true, the server has been shutdown.\nNumber of accepted ‘iroh derp http’ connection upgrades\n<code>FrameType::SendPacket</code> dropped that are disco messages\n<code>FrameType::SendPacket</code> received that are disco messages\n<code>FrameType::SendPacket</code> sent that are disco messages\nNumber of connections we have removed because of an error\nReturns the argument unchanged.\nNumber of <code>FrameType::Ping</code>s received\nAn http specific relay Client and relay Server. Allows for …\nCalls <code>U::from(self)</code>.\nA full-fledged iroh-relay server.\nServer loop handler\nbased on tailscale/tailcfg/derpmap.go\nThe DER encoded x509 cert to send after <code>LetsEncrypt</code> …\nA map of the different relay IDs to the <code>RelayNode</code> …\nPackets of other <code>FrameType</code>s dropped\nPackets of other <code>FrameType</code>s received\nPackets of other <code>FrameType</code>s sent\nsecret_key of the client\n<code>FrameType::SendPacket</code> dropped, that are not disco messages\n<code>FrameType::SendPacket</code> received, that are not disco messages\n<code>FrameType::SendPacket</code> sent, that are not disco messages\nNumber of <code>FrameType::Pong</code>s sent\nbased on tailscale/derp/derp_server.go\nChannel on which to communicate to the <code>ServerActor</code>\nWhether this relay server should only be used for STUN …\nThe stun port of the relay server.\nNumber of unique client keys per day\nNumber of <code>FrameType::Unknown</code> received\nThe <code>RelayUrl</code> where this relay server can be dialed.\nNumber of accepted websocket connections\nOptionally specifies how long to wait before failing when …\nThe received packet bytes.\nIf set, is a description of why the connection is …\nAn advisory duration that the client should wait before …\nThe <code>PublicKey</code> of the packet sender.\nHow many bytes the server will allow in one burst, …\nHow many bytes per second the server says it will accept, …\nAn advisory duration for how long the client should …\nA relay Client. Cheaply clonable. Call <code>close</code> to shutdown …\nThe Builder returns a <code>Client</code> and a started <code>ClientWriter</code> …\nCall <code>ClientWriter::run</code> to listen for messages to send to …\nThe kinds of messages we can send to the …\nA one-way message from server to client, declaring the …\nA one-way empty message from server to client, just to …\nTell the server whether or not this client is the user’s …\nSend a packet (addressed to the <code>PublicKey</code>) to the server\nIndicates that the client identified by the underlying …\nSend a ping to the server\nRequest from a client or server to reply to the other side …\nSend a pong to the server\nReply to a <code>ReceivedMessage::Ping</code> from a client or server …\nThe type of message received by the <code>Client</code> from the …\nRepresents an incoming packet.\nSent by the server upon first connect.\nA one-way message from server to client, advertising that …\nShutdown the writer\nClose the client\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether or not this <code>Client</code> is closed.\nThe local address that the <code>Client</code> is listening on.\nOur local address, if known.\nSends a packet that tells the server whether this client …\nThe reader channel, receiving incoming messages.\nReads a messages from a relay server.\nSends a packet to the node identified by <code>dstkey</code>\nSend a ping with 8 bytes of random data.\nRespond to a ping request. The <code>data</code> field should be filled …\nChannel on which to communicate to the server. The …\nJoinHandle for the <code>ClientWriter</code> task\nThe received packet bytes.\nIf set, is a description of why the connection is …\nAn advisory duration that the client should wait before …\nThe <code>PublicKey</code> of the packet sender.\nHow many bytes the server will allow in one burst, …\nHow many bytes per second the server says it will accept, …\nAn advisory duration for how long the client should …\nChannels that the <code>ClientConnManager</code> uses to communicate …\nA builds a <code>ClientConnManager</code> from a <code>PublicKey</code> and an io …\nManages all the reads and writes to this client. It …\nThe <code>super::server::Server</code> side representation of a …\nCreates a client from a connection, which starts a read …\nChannels that allow the <code>ClientConnManager</code> (and the Server) …\nStatic after construction, process-wide unique counter, …\nQueue of important packets intended for the client\nImportant packets queued to send to the client\nSent when connection closes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse the SEND_PACKET frame, getting the destination and …\nHandles read results.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIo to talk to the client\nControls how quickly two connections with the same client …\n<code>PublicKey</code> of this client\nCreates a client from a connection &amp; starts a read and …\nNotify the client that a previous sender has disconnected\nNotify the client that a previous sender has disconnected\nNotes that the client considers this the preferred …\nSends a <code>keep alive</code> frame, does not flush\nWrites contents to the client in a <code>RECV_PACKET</code> frame. If …\nSends a peer gone frame, does not flush\nSend a <code>pong</code> frame, does not flush\nQueue of packets intended for the client\nPackets queued to send to the client\nChannels used to communicate with the server about actions …\nPreferred indicates if this is the preferred connection to …\nShutdown the <code>ClientConnManager</code> reader and writer loops and …\nMax time we wait to complete a write to the client\nSend the given packet to the server. The server will …\nRepresents a connection to a client.\nNumber of times we try to send to a client connection …\nThe client connection associated with the <code>PublicKey</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRecord that this client sent a packet to the <code>dst</code> client\nRecord that <code>src</code> sent or forwarded a packet to <code>dst</code>\nAttempt to send a packet to client with <code>PublicKey</code> <code>key</code>\nlist of peers we have sent messages to\nRemoves the client from the map of clients, &amp; sends a …\nmagic + 32b pub key + 24B nonce + bytes\nThe one byte frame type at the beginning of the frame …\nSent from server to client to tell the client if their …\nno payload, no-op (to be replaced with ping/pong)\nThe Relay magic number, sent in the FrameType::ClientInfo …\nThe maximum size of a packet sent over relay. (This only …\nindicates this is NOT the client’s home node\n1 byte payload: 0x01 or 0x00 for whether this is client’…\nThe number of packets buffered for sending per client\nProtocol flow:\nProtocolVersion is bumped whenever there’s a …\nSent from server to client to signal that a previous …\nFrames 9-11 concern meshing, which we have eliminated from …\n8 byte payload, the contents of ping being replied to\nv0/1 packet bytes, v2: 32B src pub key + packet bytes\nSent from server to client for the server to declare that …\n32B dest pub key + packet bytes\nTries to decode a frame received over websockets.\nEncodes this frame for sending over websockets.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSerialized length (without the frame header)\nReads the <code>FrameType::ClientInfo</code> frame from the client (its …\nReceives the next frame and matches the frame type. If the …\nWrites a <code>FrameType::ClientInfo</code>, including the client’s …\nWrites complete frame, errors if it is unable to write …\nWrites it self to the given buffer.\nThe inner actor is gone, likely means things are shutdown.\nThe relay <code>super::client::Client</code> failed to build\nThis <code>Client</code> cannot acknowledge pings\nAn HTTP Relay client.\nBuild a Client.\nPossible connection errors on the <code>Client</code>\nReceiving end of a <code>Client</code>.\nThe client is closed\nThere was a connection timeout error\nThere was an error dialing\nThere was an error from the task doing the dialing\nThere was an error with DNS resolution\nThere was a timeout resolving DNS.\nThere was an http error <code>http::Error</code>.\nThere was http server <code>hyper::Error</code>\nBoth IPv4 and IPv6 are disabled for this relay node\nThe given <code>Url</code> is invalid\nThe legacy HTTP path under which the relay used to accept …\nThe legacy HTTP path under which the relay used to allow …\nUses Let’s Encrypt as the Certificate Authority. This is …\nManually added tls acceptor. Generally used for tests or …\nThere no underlying relay <code>super::client::Client</code> client …\nNo local addresses exist\nNo relay nodes are available with that name\nThe ping request was aborted\nThe ping request timed out\nThe HTTP upgrade protocol used for relaying.\nThe connection failed to proxy\nThe HTTP path under which the relay accepts relaying …\nThe HTTP path under which the relay allows doing latency …\nThere was an error receiving a packet\nRelays over the custom relaying protocol with a custom …\nNo relay nodes are available\nThere was an error sending a packet\nThe Relay HTTP server.\nBuilder for the Relay HTTP Server.\nA handle for the <code>Server</code>.\nThe relay node specified only allows STUN requests\nTLS Certificate Authority acceptor.\nConfiguration to use for the TLS connection\nThere was an unexpected status code\nThe connection failed to upgrade\nRelays over websockets.\nAn error related to websockets, either errors with parsing …\nThe kind\nThe ip + port combination for this server.\nDefault is None\nDefault is false\nBased on tailscale/derp/derphttp/derphttp_client.go\nThe server config\nReturns the argument unchanged.\nA map of request handlers to routes.\nHeaders to use for HTTP responses.\nAllow self-signed certificates from relay servers\nCalls <code>U::from(self)</code>.\nDefault is false\nDefault is false\n404 not found response.\nTries to match the value of an HTTP upgrade header to …\nRelay protocol\nHTTP Proxy\nUse a custom relay response handler.\nThe secret key for this Server.\nExpected PublicKey of the server\nOptional tls configuration/TlsAcceptor combination.\nThe HTTP upgrade header used or expected.\nServer url.\nThe inner actor is gone, likely means things are shutdown.\nThe relay <code>super::client::Client</code> failed to build\nThis <code>Client</code> cannot acknowledge pings\nAn HTTP Relay client.\nBuild a Client.\nPossible connection errors on the <code>Client</code>\nReceiving end of a <code>Client</code>.\nThe client is closed\nThere was a connection timeout error\nThere was an error dialing\nThere was an error from the task doing the dialing\nThere was an error with DNS resolution\nThere was a timeout resolving DNS.\nThere was an http error <code>http::Error</code>.\nThere was http server <code>hyper::Error</code>\nBoth IPv4 and IPv6 are disabled for this relay node\nThe given <code>Url</code> is invalid\nUsed to allow self signed certificates in tests\nThere no underlying relay <code>super::client::Client</code> client …\nNo local addresses exist\nNo relay nodes are available with that name\nThe ping request was aborted\nThe ping request timed out\nThe connection failed to proxy\nThere was an error receiving a packet\nNo relay nodes are available\nThere was an error sending a packet\nThe relay node specified only allows STUN requests\nThere was an unexpected status code\nThe connection failed to upgrade\nAn error related to websockets, either errors with parsing …\nReturns if we should prefer ipv6 it replaces the …\nDefault is None\nBuild the <code>Client</code>\nEnable this <code>Client</code> to acknowledge pings.\nDefault is false\nClose the http relay connection.\nDisconnect the http relay connection.\nClose the underlying relay connection. The next time the …\nConnect to a relay Server and returns the underlying relay …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSkip the verification of the relay server’s SSL …\nAllow self-signed certificates from relay servers\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the underlying relay connection is …\nIndicate this client is the preferred way to communicate …\nDefault is false\nIndicates this client is a prober\nDefault is false\nGet the local addr of the connection. If there is no …\nCreate a new <code>ClientBuilder</code>\nLet the server know that this client is the preferred …\nSend a ping to the server. Return once we get an expected …\nReports whether IPv4 dials should be slightly delayed to …\nSets whether to connect to the relay via websockets or not.\nRelay protocol\nSet an explicit proxy url to proxy all HTTP(S) traffic …\nHTTP Proxy\nThe public key for this client\nReads a message from the server. Returns the message and …\nNote that we have sent a ping, and store the …\nSend a packet to the server.\nSend a pong back to the server.\nThe expected <code>PublicKey</code> of the <code>super::server::Server</code> we are …\nExpected PublicKey of the server\nSets the server url\nSends the HTTP upgrade request to the relay server.\nRemove the associated <code>oneshot::Sender</code> for <code>data</code> &amp; return it.\nServer url.\nPass the connection to a <code>ClientConnHandler</code> to get added to …\nContains the error value\nUses Let’s Encrypt as the Certificate Authority. This is …\nManually added tls acceptor. Generally used for tests or …\nContains the success value\nReturn some static response. Used when the http(s) should …\nAction to take when a connection is made at the relay …\nThe hyper Service that servers the actual relay endpoints\nThe Relay HTTP server.\nBuilder for the Relay HTTP Server.\nA handle for the <code>Server</code>.\nTLS Certificate Authority acceptor.\nConfiguration to use for the TLS connection\nThe kind\nReturns the local address of this server.\nReturns the address the server is bound on.\nThe ip + port combination for this server.\nCreates a new <code>BytesBody</code> with no content.\nCreates a new <code>BytesBody</code> with given content.\nThe server config\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a handle for this server.\nHandle the incoming connection.\nA map of request handlers to routes.\nAdds HTTP headers to responses.\nHeaders to use for HTTP responses.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new ServerBuilder.\n404 not found response.\nSets a custom “404” handler.\nThe server HTTP handler to do HTTP upgrades.\nHandles the relay endpoint in a custom way.\nUse a custom relay response handler.\nAdds a custom handler for a specific Method &amp; URI.\nThe <code>SecretKey</code> identity for this relay server.\nThe secret key for this Server.\nWrapper for the actual http connection (with upgrades)\nCloses the underlying relay server and the HTTP(S) server …\nGracefully shut down the server.\nBuilds and spawns an HTTP(S) Relay Server.\nReturns the <code>JoinHandle</code> for the supervisor task managing …\nServes all requests content using TLS.\nOptional tls configuration/TlsAcceptor combination.\nServe the tls connection\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTLS certificate configuration.\nContains the error value\nUse Let’s Encrypt.\nRate limits.\nUse a static TLS key and certificate chain.\nContains the success value\nConfiguration for the Relay HTTP and HTTPS server.\nHorrible hack to make <code>relay::http::Server</code> behave somewhat.\nA running Relay + STUN server.\nConfiguration for the full Relay &amp; STUN server.\nConfiguration for the STUN server.\nTLS configuration for Relay server.\nBurst limit for accepting new connection. Unlimited if not …\nRate limit for accepting new connection. Unlimited if not …\nThe socket address on which the STUN server should bind.\nCreates a new <code>BytesBody</code> with no content.\nMode for getting a cert.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandles a single STUN request, doing all logging required.\nThe socket address the HTTP server is listening on.\nThe address of the HTTP server, if configured.\nThe socket address on which the Relay HTTP server should …\nThe socket address the HTTPS server is listening on.\nThe address of the HTTPS server, if the relay server is …\nThe socket address on which to serve the HTTPS server.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRate limits.\nSocket to serve metrics on.\nHTTP latency queries\nConfiguration for the Relay server, disabled if <code>None</code>.\nHandle to the relay server.\nSupervisor for the relay server tasks.\nThis is a future that never returns, drop it to …\nThe iroh secret key of the Relay server.\nFor captive portal detection.\nRuns a STUN server.\nRequests graceful shutdown.\nStarts the server.\nConfiguration for the STUN server, disabled if <code>None</code>.\nThe socket address the STUN server is listening on.\nThe address of the STUN server, if configured.\nThe main task running the server.\nReturns the handle for the task.\nTLS configuration for the HTTPS server.\nThe TLS certificate chain.\nConfiguration for Let’s Encrypt certificates.\nThe TLS private key.\nStunMetrics tracked for the DERPER\nNumber of bad requests, either non-stun packets or …\nNumber of failures\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of successful requests over ipv4\nNumber of successful requests over ipv6\nNumber of stun requests made\nUse a custom relay map.\nUse the default relay map, with production relay servers …\nDisable relay servers completely.\nConfiguration of all the relay servers that can be used.\nConfiguration options for the relay servers of the magic …\nInformation on a specific relay server.\nUse the staging relay servers from n0.\nIs this a known node?\nCreates a new `RelayMap with a single relay server …\nCreate an empty relay map.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs the [<code>RelayMap] from an iterator of [</code>RelayNode`]…\nReturns a [<code>RelayMap] from a [</code>RelayUrl`].\nGet the given node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre there any nodes in this map?\nHow many nodes are known?\nReturns an <code>Iterator</code> over all known nodes.\nA map of the different relay IDs to the <code>RelayNode</code> …\nWhether this relay server should only be used for STUN …\nThe stun port of the relay server.\nThe <code>RelayUrl</code> where this relay server can be dialed.\nReturns the sorted relay URLs.\nMetrics tracked for the relay server\nNumber of connections we have accepted\nBytes received from a <code>FrameType::SendPacket</code>\nBytes sent from a <code>FrameType::SendPacket</code>\nNumber of accepted ‘iroh derp http’ connection upgrades\n<code>FrameType::SendPacket</code> dropped that are disco messages\n<code>FrameType::SendPacket</code> received that are disco messages\n<code>FrameType::SendPacket</code> sent that are disco messages\nNumber of connections we have removed because of an error\nReturns the argument unchanged.\nNumber of <code>FrameType::Ping</code>s received\nCalls <code>U::from(self)</code>.\nPackets of other <code>FrameType</code>s dropped\nPackets of other <code>FrameType</code>s received\nPackets of other <code>FrameType</code>s sent\n<code>FrameType::SendPacket</code> dropped, that are not disco messages\n<code>FrameType::SendPacket</code> received, that are not disco messages\n<code>FrameType::SendPacket</code> sent, that are not disco messages\nNumber of <code>FrameType::Pong</code>s sent\nNumber of unique client keys per day\nNumber of <code>FrameType::Unknown</code> received\nNumber of accepted websocket connections\nHandle incoming connections to the Server.\nWhether or not the underlying <code>tokio::net::TcpStream</code> is …\nA plain non-Tls <code>tokio::net::TcpStream</code>\nA relay server.\nA Tls wrapped <code>tokio::net::TcpStream</code>\nAborts the server.\nAdds a new connection to the server and serves it.\nDone token, forces a hard shutdown. To gracefully …\nCreate a <code>ClientConnHandler</code>, which can verify connections …\nAll clients connected to this server\nCloses the server and waits for the connections to …\nWhen true, the server has been shutdown.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitializes the <code>Server</code> with a self-signed x509 cert …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether or not the relay Server is closed.\nServer loop handler\nReturns the server metadata cert that can be sent by the …\nThe DER encoded x509 cert to send after <code>LetsEncrypt</code> …\nTODO: replace with builder\nReturns the server’s public key.\nReturns the server’s secret key.\nsecret_key of the client\nChannel on which to communicate to the <code>ServerActor</code>\nUpdates the client counter.\nOptionally specifies how long to wait before failing when …\nA request to write a dataframe to a Client\nThe data packet bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe sender of the packet\nThe relay protocol version that the client was built with.\nThe <code>AlternateServer</code>atribute\nErrors that can occur when handling a STUN packet.\nThe <code>ErrorCode</code>atribute\nerror response\nThe <code>Fingerprint</code>atribute\nindication\nSTUN request had bogus fingerprint.\nThe STUN message could not be parsed or is otherwise …\nSTUN response has malformed attributes.\nThe <code>MappedAddress</code>atribute\nThe STUN message class. Although there are four message …\nClass used to decode STUN messages\nThe <code>MessageIntegrity</code>atribute\nThe <code>MessageIntegritySha256</code>atribute\nSTUN request didn’t end in fingerprint.\nThe <code>Nonce</code>atribute\nSTUN request is not a binding request when it should be.\nSTUN packet is not a response when it should be.\nThe <code>PasswordAlgorithm</code>atribute\nThe <code>PasswordAlgorithms</code>atribute\nThe <code>Realm</code>atribute\nrequest\nThe <code>Software</code>atribute\nSTUN Attributes that can be attached to a <code>StunMessage</code>\nDescribes an error decoding a <code>StunMessage</code>\nsuccess response\nThe transaction ID is a 96-bit identifier, used to …\nThe <code>Unknown</code>atribute\nThe <code>UnknownAttributes</code>atribute\nThe <code>UserHash</code>atribute\nThe <code>UserName</code>atribute\nThe <code>XorMappedAddress</code>atribute\nReturns a reference to the internal attribute value or an …\nReturns a reference to the bytes that represents the …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns a reference to the internal attribute value or an …\nReturns the STUN attribute type of this instance.\nDecodes the STUN raw buffer\nCreates a cryptographically random transaction ID chosen …\nReturns a reference to the <code>AlternateServer</code> attribute.\nReturns a reference to the <code>ErrorCode</code> attribute.\nReturns a reference to the <code>Fingerprint</code> attribute.\nReturns a reference to the <code>MappedAddress</code> attribute.\nReturns a reference to the <code>MessageIntegrity</code> attribute.\nReturns a reference to the <code>MessageIntegritySha256</code> …\nReturns a reference to the <code>Nonce</code> attribute.\nReturns a reference to the <code>PasswordAlgorithm</code> attribute.\nReturns a reference to the <code>PasswordAlgorithms</code> attribute.\nReturns a reference to the <code>Realm</code> attribute.\nReturns a reference to the <code>Software</code> attribute.\nReturns a reference to the <code>Unknown</code> attribute.\nReturns a reference to the <code>UnknownAttributes</code> attribute.\nReturns a reference to the <code>UserHash</code> attribute.\nReturns a reference to the <code>UserName</code> attribute.\nReturns a reference to the <code>XorMappedAddress</code> attribute.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the context associated to this decoder\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReports whether b is a STUN message.\nReturns true if this <code>StunAttribute</code> is <code>AlternateServer</code>\nReturns true if this <code>StunAttribute</code> is <code>ErrorCode</code>\nReturns true if this <code>StunAttribute</code> is <code>Fingerprint</code>\nReturns true if this <code>StunAttribute</code> is <code>MappedAddress</code>\nReturns true if this <code>StunAttribute</code> is <code>MessageIntegrity</code>\nReturns true if this <code>StunAttribute</code> is …\nReturns true if this <code>StunAttribute</code> is <code>Nonce</code>\nReturns true if this <code>StunAttribute</code> is <code>PasswordAlgorithm</code>\nReturns true if this <code>StunAttribute</code> is <code>PasswordAlgorithms</code>\nReturns true if this <code>StunAttribute</code> is <code>Realm</code>\nReturns true if this <code>StunAttribute</code> is <code>Software</code>\nReturns true if this <code>StunAttribute</code> is <code>Unknown</code>\nReturns true if this <code>StunAttribute</code> is <code>UnknownAttributes</code>\nReturns true if this <code>StunAttribute</code> is <code>UserHash</code>\nReturns true if this <code>StunAttribute</code> is <code>UserName</code>\nReturns true if this <code>StunAttribute</code> is <code>XorMappedAddress</code>\nSTUN Methods Registry\nParses a STUN binding request.\nParses a successful binding response STUN packet. The IP …\nGenerates a binding request STUN packet.\nGenerates a binding response.\nBinding\nReserved\nShared secret\nA drop guard to clean up test infrastructure.\nHandle and drop guard for test DNS and Pkarr servers.\nCreate a DNS resolver with a single nameserver.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe socket address of the DNS server.\nThe node origin domain.\nThe HTTP URL of the Pkarr server.\nRuns a relay server with STUN enabled suitable for tests.\nThe shared state of the DNS and Pkarr servers.\nHandle and drop guard for test DNS and Pkarr servers.\nCreate a <code>ConcurrentDiscovery</code> with <code>DnsDiscovery</code> and …\nCreate a <code>DnsResolver</code> configured to use the test DNS server.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe socket address of the DNS server.\nThe node origin domain.\nWait until a Pkarr announce for a node is published to the …\nThe HTTP URL of the Pkarr server.\nRun DNS and Pkarr servers on localhost.\nRun DNS and Pkarr servers on localhost with the specified …\nThe shared state of the DNS and Pkarr servers.\nTrait used by <code>run_dns_server</code> for answering DNS queries.\nCreate a DNS resolver with a single nameserver.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRun a DNS server.\nReturns the argument unchanged.\nReturns a mutex guard, do not hold over await points\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA token containing everything to get a file from the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new ticket.\nThe <code>NodeAddr</code> of the provider for this ticket.\nX.509 certificate handling.\nCreate a TLS client configuration.\nCreate a TLS server configuration.\nTLS 1.3 certificates and handshakes handling for libp2p\nAn error that occurs during certificate generation.\nThe libp2p Public Key Extension is a X.509 extension with …\nThe peer signs the concatenation of the string …\nAn X.509 certificate with a libp2p-specific extension is …\nThe contents of the specific libp2p extension, containing …\nAn error that occurs during certificate parsing.\nThe public host key and the signature are ANS.1-encoded …\nAn error that occurs during signature verification.\nEncode this value as ASN.1 DER using the provided <code>Writer</code>.\nCompute the length of this value in bytes when encoded as …\nThis is a specific libp2p Public Key Extension with two …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a self-signed TLS certificate that includes a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttempts to parse the provided bytes as a <code>P2pCertificate</code>.\nInternal function that only parses but does not verify the …\nThe <code>PublicKey</code> of the remote peer.\nGet a <code>ring::signature::UnparsedPublicKey</code> for this …\nThis signature provides cryptographic proof that the peer …\nReturn the signature scheme corresponding to …\nThis method validates the certificate according to libp2p …\nVerify the <code>signature</code> of the <code>message</code> signed by the secret …\nA list of the TLS 1.3 cipher suites supported by rustls.\nImplementation of the <code>rustls</code> certificate verification …\nThe protocol versions supported by this verifier.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe peer ID we intend to connect to\nReturn the list of SignatureSchemes that this verifier …\nWhen receiving the certificate chain, an endpoint MUST …\nA join handle that owns the task it is running, and aborts …\nHolds a handle to a task and aborts it on drop.\nResolves to pending if the inner is <code>None</code>.\nA join handle that owns the task it is running, and aborts …\nIO utility to chain <code>AsyncRead</code>s together.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFuture to be polled.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>CancelOnDrop</code> with a name and a handle to a task.\nCheck if we are running in “relay only” mode, as …\nStream for the <code>chain</code> method.\nChain two <code>AsyncRead</code>s together.\nReturns the argument unchanged.\nGets mutable references to the underlying readers in this …\nGets pinned mutable references to the underlying readers …\nGets references to the underlying readers in this <code>Chain</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>Chain</code>, returning the wrapped readers.")