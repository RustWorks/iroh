searchState.loadedDescShard("iroh_gossip", 0, "Broadcast messages to peers subscribed to a topic\nA higher level wrapper for the gossip engine that manages …\nMetrics for iroh-gossip\nNetworking for the <code>iroh-gossip</code> protocol\nImplementation of the iroh-gossip protocol, as an IO-less …\nBroadcast a message to all nodes in the swarm\nBroadcast a message to all direct neighbors\nSend a gossip message\nType alias for a stream of gossip updates, so we don’t …\nUpdate from a subscribed gossip topic\nType alias for a sink of gossip events.\nA message was received\nA gossip engine that manages gossip subscriptions and …\nGossip event An event to be emitted to the application for …\nThe topic is currently joining. Making new subscriptions …\nWe missed some messages\nThe topic is currently live. New subscriptions can be …\nA gossip message\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nThe topic is currently quitting. We can’t make new …\nA gossip message was received for this topic\nThe mutable state of the gossip engine.\nJoin a gossip topic\nThe initial bootstrap nodes\nThe content of the message\nThe node that delivered the message. This is not the same …\nDispatch gossip events to all subscribed streams.\nDispatch gossip events to all subscribed streams, and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtract all senders from the state.\nCall join, then await the result.\nJoin a gossip topic and handle turning waiting streams …\nCreate a new gossip dispatcher with the given gossip …\nSwitch the state of a topic to live.\nQuit a gossip topic and handle the result of the quitting.\nThe scope of the message. This tells us if the message is …\ntokio::spawn but returns an <code>AbortingJoinHandle</code> that owns …\nSubscribe to a gossip topic.\nThe maximum number of messages that can be buffered in a …\nthe single task that dispatches gossip events to all …\nTry to send an event to a sink.\nHandle updates from the client.\nHandle updates from the client, and handle update loop …\nThe task that is driving the join future.\nSet of bootstrap nodes we are using.\nSet of bootstrap nodes we are using.\nThe task that is driving the quit future.\nStream/sink pairs that are waiting for the topic to become …\nStream/sink pairs that are waiting for the topic to quit so\nEnum of metrics for the module\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nActor that sends and handles messages between the …\nBroadcast a message for this topic.\nBroadcast a message on a topic.\nCommands for the gossip protocol\nExecute a command from the application.\nHandle a new QUIC connection, either from accept (external …\nWhether a connection is initiated by us (Dial) or by the …\nClose the connection to a peer on the network level.\nEmit an event to the application.\nEvents emitted from the gossip protocol\nALPN protocol name\nPublish and subscribe on gossiping topics.\nChannel capacity for the InEvent message queue (single)\nJoin this topic and connect to peers.\nJoin a topic with a list of peers. Reply with oneshot once …\nFuture that completes once at least one peer is joined for …\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nChannel capacity for endpoint change message queue (single)\nUpdated peer data\nPeer disconnected on the network level.\nLeave this topic and drop all state.\nLeave a topic, send disconnect messages and drop all state.\nA gossip message was received for this topic\nMessage received from the network.\nChannel capacity for the send queue (one per connection)\nName used for logging when new node addresses are added …\nChannel capacity for all subscription broadcast channels …\nChannel capacity for topic subscription broadcast channels …\nSchedule a timer. The runtime is responsible for sending …\nSend a message on the network\nSubscribe to a topic. Return oneshot which resolves to a …\nSubscribe to a topic. Return oneshot which resolves to a …\nChannel capacity for the ToActor message queue (single)\nTrigger a previously scheduled timer.\nInput messages for the gossip <code>Actor</code>.\nUpdate the opaque peer data about yourself.\nBroadcast a message on a topic to all peers in the swarm.\nBroadcast a message on a topic to the immediate neighbors.\nChannels to send outbound messages into the connection …\nCurrently opened quinn connections to peers\nDial machine to connect to peers\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSpawn a gossip actor and get a handle for it\nHandle an incoming <code>Connection</code>.\nInput events to the state (emitted from the connection …\nSender for the state input (cloned into the connection …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJoin a topic and connect to peers.\nGet the maximum message size configured for this gossip …\nUpdates of discovered endpoint addresses\nQueued messages that were to be sent before a dial …\nQuit a topic.\nProtocol state\nSubscribe to messages and event notifications for a topic.\nSubscribe to all events published on topics that you …\nBroadcast senders for wildcard subscriptions from the …\nBroadcast senders for active topic subscriptions from the …\nQueued timers\nInput messages to the actor\nSet info on our direct addresses.\nUtilities for iroh-gossip networking\nA <code>TimerMap</code> with an async method to wait for the next timer …\nReturns the argument unchanged.\nInsert a new entry at the specified instant\nCalls <code>U::from(self)</code>.\nCreate a new timer map\nReads a length prefixed message.\nRead a length-prefixed message and decode as <code>ProtoMessage</code>;\nWait for the next timer to expire and return an iterator …\nWrite a <code>ProtoMessage</code> as a length-prefixed, …\nThe scope to deliver the message to.\nThis message was received from a direct neighbor that …\nThe message is broadcast only to the immediate neighbors …\nOpaque binary data that is transmitted on messages that …\nThe identifier for a peer.\nPeerInfo contains a peer’s identifier and the opaque …\nThe broadcast scope of a gossip message.\nThis message was received from the swarm, with a distance …\nThe message is broadcast to all peers in the swarm.\nGet the peer data as a byte slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nImplementation of the HyParView membership protocol\nGet a reference to the contained <code>bytes::Bytes</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>PeerData</code> from a byte buffer.\nImplementation of the Plumtree epidemic broadcast tree …\nThe protocol state of the <code>iroh-gossip</code> protocol.\nThis module contains the implementation of the gossiping …\nUtilities used in the protocol implementation\nConfiguration for the swarm membership layer\nMessage sent when leaving the swarm or closing down to …\nRequest to disconnect from a peer. If <code>Disconnect::alive</code> is …\nAsk the IO layer to close the connection to peer <code>PI</code>.\nEmit an <code>Event</code> to the application.\nEvent emitted by the <code>State</code> to the application.\nA message informing other peers that a new peer joined the …\nWhen receiving Join, ForwardJoin is forwarded to the peer…\nHigh priority join that may not be denied.\nInput event for HyParView\nSent to a peer if you want to join the swarm\nLow priority join that can be denied.\nMessages that we can send and receive from peers within …\nA neighbor message is sent after adding a peer to our …\nRequest to add sender to an active view of recipient. If …\nA peer was removed from our set of active connections.\nA peer was added to our set of active connections.\nOutput event for HyParView\nNew <code>PeerData</code> was received for peer <code>PI</code>.\nA peer was disconnected on the IO layer.\nThe priority of a <code>Join</code> message\nQuit the swarm, informing peers about us leaving.\nA <code>Message</code> was received from a peer.\nSend a join request to a peer.\nSchedule a <code>Timer</code>.\nAsk the IO layer to send a <code>Message</code> to peer <code>PI</code>.\nShuffle messages are sent occasionally to shuffle our …\nA shuffle request is sent occasionally to re-shuffle the …\nOnce a shuffle messages reaches a <code>Ttl</code> of 0, a peer replies …\nPeers reply to <code>Message::Shuffle</code> requests with a random …\nThe state of the HyParView protocol\nKinds of timers HyParView needs to schedule.\nA timer has expired.\nThe time-to-live for this message.\nUpdate the peer data that is transmitted on join requests.\nNumber of hops a <code>ForwardJoin</code> message is propagated until …\nThe active view, i.e. peers we are connected to\nNumber of peers to which active connections are maintained\nAdd a peer to the active view.\nAdd a peer to the passive view.\nWhether we are actually shutting down or closing the …\nProtocol configuration (cannot change at runtime)\nThe user data of the peer sending this message.\nDefault values for the HyParView layer\nRemove a random peer from the active view.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOur peer identity\nOur opaque user data to transmit to peers on join messages\nTimeout after which a <code>Neighbor</code> request is considered failed\nA random subset of the active and passive peers of the …\nA random subset of the active and passive peers of the …\nHandle a <code>Message::Shuffle</code>\nThe peer that initiated the shuffle request.\nNumber of hops a <code>ForwardJoin</code> message is propagated until …\nThe passive view, i.e. peers we know about but are not …\nNumber of peers for which contact information is …\nThe peer that newly joined the swarm\nThe opaque user peer data we received for other peers\nGet the peer <code>PeerInfo</code> for a peer.\nThe set of neighbor requests we sent out but did not yet …\nThe priority of the <code>Join</code> or <code>ForwardJoin</code> message that …\nRemove a peer from the active view.\nWhether we should reply to the peer with a Disconnect …\nRandom number generator\nNumber of active peers to be included in a <code>Shuffle</code> request.\nInterval duration for shuffle requests\nNumber of passive peers to be included in a <code>Shuffle</code> …\nNumber of hops a <code>Shuffle</code> message is propagated until a …\nWhether a shuffle timer is currently scheduled\nStatistics\nThe time-to-live for this message\nThe time-to-live for this message.\nBroadcast the contained payload to the given scope.\nConfiguration for the gossip broadcast layer.\nThe scope to deliver the message to.\nDispatch the <code>Message::IHave</code> in our lazy push queue.\nEmit an <code>Event</code> to the application.\nEvent emitted by the <code>State</code> to the application.\nEvict the message cache\nPayload messages transmitted by the protocol.\nWhen receiving Gossip, emit as event and forward full …\nControl message to signal a peer that they have been moved …\nWhen receiving Graft, move the peer to the eager set and …\nControl message to inform peers we have a message without …\nWhen receiving IHave, do nothing initially, and request …\nEvents Plumtree is informed of from the peer sampling …\nMessages that we can send and receive from peers within …\nA message identifier, which is the message content’s …\nPeer <code>PI</code> has disconnected from the topic.\nNew member <code>PI</code> has joined the topic.\nThis message was received from a direct neighbor that …\nThe message is broadcast only to the immediate neighbors …\nEvents Plumtree emits.\nWhen receiving Prune, move the peer from the eager to the …\nA new gossip message was received.\nA <code>Message</code> was received from the peer.\nNumber of delivery hops a message has taken.\nSchedule a <code>Timer</code>.\nThe broadcast scope of a gossip message.\nRequest the content for <code>MessageId</code> by sending <code>Message::Graft</code>…\nAsk the IO layer to send a <code>Message</code> to peer <code>PI</code>.\nState of the plumtree.\nStats about this topic’s plumtree.\nThis message was received from the swarm, with a distance …\nThe message is broadcast to all peers in the swarm.\nKinds of timers Plumtree needs to schedule.\nA timer has expired.\nMoves peer into eager set.\nMoves peer into lazy set.\nGet as byte slice.\nSend a gossip message.\nPayloads of received messages.\nHow often the internal caches will be checked for expired …\nConfiguration for this plumtree.\nThe content of the gossip message.\nMessage contents.\nNumber of control messages received so far.\nSensible defaults for the plumtree configuration\nThe peer that we received the gossip message from. Note …\nTimeout after which <code>IHave</code> messages are pushed to peers.\nWhether a <code>Timer::DispatchLazyPush</code> has been scheduled.\nImmediately sends message to eager peers.\nSet of peers used for payload exchange.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from a byte array.\nCreate a <code>[MessageId]</code> by hashing the message content.\nWhen receiving an <code>IHave</code> message, this timeout is …\nThis timeout is registered when sending a <code>Graft</code> message. …\nMessage ids for which a <code>Timer::SendGraft</code> has been …\nHandle an <code>InEvent</code>.\nHandle receiving a <code>Message</code>.\nId of the message.\nId of the message.\nMessage id that triggers the graft, if any. On receiving a …\nSet to false after the first message is received. Used for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this message was directly received from its …\nQueue lazy message announcements into the queue that will …\nSet of peers used for control message exchange.\nMax round seen so far.\nOur address.\nDuration for which to keep gossip messages in the internal …\nDuration for which to keep the <code>MessageId</code>s for received …\nMessages for which a <code>MessageId</code> has been seen via a …\nInitialize the <code>State</code> of a plumtree.\nGet a clone of this <code>Gossip</code> message and increase the …\nDispatches messages from lazy queue over to lazy peers.\nHandle receiving a <code>Message::Gossip</code>.\nHandle receiving a <code>Message::Graft</code>.\nHandle receiving a <code>Message::IHave</code>.\nHandle a <code>InEvent::NeighborDown</code> when a peer leaves the …\nHandle a <code>InEvent::NeighborUp</code> when a peer joins the topic.\nHandle receiving a <code>Message::Prune</code>.\nA scheduled <code>Timer::SendGraft</code> has reached it’s deadline.\nThe protocol performs a tree optimization, which promotes …\nOptimize the tree by pruning the <code>sender</code> of a …\nNumber of payload messages received so far.\nMessages for which the full payload has been seen.\nDelivery round of the message.\nDelivery round of the <code>Message::IHave</code> that triggered this …\nThe broadcast scope of the message.\nScope to broadcast to.\nGet access to the <code>Stats</code> of the plumtree.\n<code>Stats</code> of this plumtree.\nValidate that the message id is the blake3 hash of the …\nExecute a command from the application.\nA control message.\nA data message.\nClose the connection to a peer on the network level.\nEmit an event to the application.\nInput event to the protocol state.\nProtocol wire message\nWhether this is a control or data message\nOutput event from the protocol state.\nUpdated peer data\nPeer disconnected on the network level.\nMessage received from the network.\nSchedule a timer. The runtime is responsible for sending …\nSend a message on the network\nThe state of the <code>iroh-gossip</code> protocol.\nA timer to be registered into the runtime\nTrigger a previously scheduled timer.\nThe identifier for a topic\nUpdate the opaque peer data about yourself.\nGet as byte slice.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from a byte array.\nHandle an <code>InEvent</code>\nCheck if a topic has any active (connected) peers.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the kind of this message\nReturns the maximum message size configured in the gossip …\nGet a reference to the node’s <code>PeerIdentity</code>\nCreate a new protocol state instance.\nGet the encoded size of this message\nGet a reference to the protocol state for a topic.\nGet an iterator for the states of all joined topics.\nGet an iterator of all joined topics.\nBroadcast a message for this topic.\nA command to the protocol state for a particular topic.\nExecute a command from the application.\nProtocol configuration\nThe default maximum size in bytes for a gossip message. …\nClose the connection to a peer on the network level.\nEmit an event to the application.\nAn event to be emitted to the application for a particular …\nA message of the gossip broadcast layer\nA timer for the gossip layer\nA trait for a concrete type to push <code>OutEvent</code>s to.\nInput event to the topic state handler.\nJoin this topic and connect to peers.\nA protocol message for a particular topic\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nAn output event from the state handler.\nEmitted when new <code>PeerData</code> was received for a peer.\nPeer disconnected on the network level.\nLeave this topic and drop all state.\nA gossip message was received for this topic\nMessage received from the network.\nSchedule a timer. The runtime is responsible for sending …\nSend a message on the network\nThe topic state maintains the swarm membership and …\nStatistics for the protocol state of a topic\nA message of the swarm membership layer\nA timer for the swarm layer\nA timer to be registered for a particular topic.\nTrigger a previously scheduled timer.\nUpdate the opaque peer data about yourself.\nConfiguration for the gossip broadcast layer\nThe address of your local endpoint.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet statistics for the gossip broadcast state\nHandle an incoming event.\nCheck if this topic has any active (connected) peers.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the kind of this message\nMax message size in bytes.\nConfiguration for the swarm membership layer\nNumber of messages received\nNumber of messages sent\nInitialize the local state with the default random number …\nPush an event in the IO container\nPush all events from an iterator into the IO container\nGet stats on how many messages were sent and received\nInitialize the local state with a custom random number …\nA hash set where the iteration order of the values is …\nA hash map where entries expire after a time\nA <code>BTreeMap</code> with <code>Instant</code> as key. Allows to process expired …\nReturns <code>true</code> if the map contains a value for the specified …\nRemove and return all entries before and equal to <code>from</code>.\nRemove all entries with an expiry instant lower or equal …\nGet the expiration time for an item.\nGet a reference to the earliest entry in the TimerMap.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet an item from the cache.\nImplement methods, display, debug and conversion traits …\nInsert a new entry at the specified instant.\nInsert an item into the cache, marked with an expiration …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the map contains no elements.\nIterate over all items in the timer map.\nIterate over all items in the cache.\nCreate an iterator over the set in the order of insertion, …\nGet the number of entries in the cache.\nCreate a new, empty TimerMap.\nPick a random element from the set.\nPick a random index for an element in the set.\nPick a random element from the set, but not any of the …\nRemove an element from the set.\nRemove an entry from the specified instant.\nRemove an item from the cache.\nRemove an element from the set by its index.\nRemove a random element from the set.\nCreate a vector of all elements in the set in random order.\nCreate a vector of all elements in the set in random …\nCreate a vector of the elements in the set in random order …\nCreate a vector of the elements in the set in random order …")