searchState.loadedDescShard("iroh", 0, "Send data over the internet.\nClient to an Iroh node.\nExpose metrics module\nNode API\nUtilities for working with iroh.\nThe blake3 hash used in Iroh.\nCryptographic key handling for <code>iroh-net</code>.\nAddressing for iroh nodes.\nbased on tailscale/tailcfg/derpmap.go\nError when decoding the base32.\nDecoding error\nDecoding error kind\nError when decoding the public key.\nError when parsing a hex or base32 string.\nInvalid length\nInvalid padding length\nInvalid symbol\nNon-zero trailing bits\nConvert to a base32 string\nConvert to a base32 string and append out <code>out</code>\nConvert to a base32 string limited to the first 10 bytes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nError kind\nParse from a base32 string into a byte array\nParse a fixed length hex or base32 string into a byte array\nDecode form a base32 string to a vector of bytes\nError position\nA format identifier\nHash type used throughout.\nA hash and format pair\nA sequence of BLAKE3 hashes\nRaw blob\nThe format\nThe hash\nError when decoding the base32.\nError when decoding the public key.\nError when deserialising a <code>PublicKey</code> or a <code>SecretKey</code>.\nThe identifier for a node in the (iroh) network.\nThe length of an ed25519 <code>PublicKey</code>, in bytes.\nA public key.\nA secret key.\nShared Secret.\nEd25519 signature.\nNetwork paths to contact an iroh-net node.\nOptions to configure what is included in a <code>NodeAddr</code> and …\nIncludes the Node ID and the direct addresses.\nOnly the Node ID is added.\nNetwork-level addressing information for an iroh-net node.\nIncludes the Node ID and the relay URL.\nIncludes the Node ID and both the relay URL, and the …\nA URL identifying a relay server.\nSocket addresses where the peer might be reached directly.\nReturns the argument unchanged.\nAddressing information to connect to <code>Self::node_id</code>.\nCalls <code>U::from(self)</code>.\nThe node’s identifier.\nThe node’s home relay url.\nThe default QUIC port used by the Relay server to accept …\nThe default STUN port used by the Relay server.\nConfiguration of all the relay servers that can be used.\nInformation on a specific relay server.\nA URL identifying a relay server.\nThe QUIC endpoint port of the relay server.\nWhether this relay server should only be used for STUN …\nThe stun port of the relay server.\nThe <code>RelayUrl</code> where this relay server can be dialed.\nA token containing everything to get a file from the …\nThis looks like a ticket, but base32 decoding failed.\nAn error deserializing an iroh ticket.\nString prefix describing the kind of iroh ticket.\nFound a ticket of with the wrong prefix, indicating the …\nA token containing information for establishing a …\nThis looks like a ticket, but postcard deserialization …\nA ticket is a serializable object combining information …\nVerification of the deserialized bytes failed.\nDeserialize from a string.\nThe <code>BlobFormat</code> for this ticket.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserialize from the base32 string representation bytes.\nThe hash of the item this ticket can retrieve.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the contents of the ticket, consuming it.\nCreates a new ticket.\nThe <code>NodeAddr</code> of the provider for this ticket.\nTrue if the ticket is for a collection and should retrieve …\nSerialize to string.\nSerialize to bytes used in the base32 string …\nA format identifier\nThe hash for the empty byte range (<code>b&quot;&quot;</code>).\nHash type used throughout.\nA hash and format pair\nA sequence of BLAKE3 hashes\nBlock size used by iroh, 2^4*1024 = 16KiB\nRaw blob\nA tag\nA hash and format pair that is protected from garbage …\nBytes of the hash.\nCreate a new tag that does not exist yet.\nDefine blob-related commands.\nHandle downloading blobs and collections concurrently and …\nFunctions to export data from a store\nConvert to a base32 string limited to the first 10 bytes …\nDefines data formats for HashSeq.\nThe format of the pinned item\nThe format\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Hash</code> from its raw bytes representation.\nThe client side API\nThe hash of the pinned item\nThe hash\nThe hash and format of the pinned item\nCreate a new hash and format pair, using the collection …\ntraits related to collections of blobs\nThe hash of the pinned item\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs hash seq format\nIs raw format\nKeep the item alive until the end of the process\nMetrics for iroh-blobs\nAdaptation of <code>iroh-blobs</code> as an <code>iroh</code> protocol.\nCalculate the hash of the provided bytes.\nCreate a new hash and format pair.\nCreate a new temp tag for the given hash and format\nProtocol for transferring content-addressed blobs and …\nThe server side API\nCreate a new hash and format pair, using the default (raw) …\nProvides a rpc protocol as well as a client for the …\nImplementations of blob stores\nConvert the hash to a hex string.\nUtility functions and types.\nAdd data from PATH to the running node.\nDelete the given blobs\nOptions for the <code>blob add</code> command.\nSubcommands for the blob command.\nWhere the data should be read from.\nData source for adding data to iroh.\nList the available blobs on the running provider.\nList the available collections on the running provider.\nPerform a database consistency check on the running node.\nDelete content on the node.\nPossible delete subcommands.\nExport a blob from the internal blob store to the local …\nDownload data to the running node’s database and provide …\nList the blobs on the running provider that are not full …\nList available content on the node.\nPossible list subcommands.\nA file or directory on the node’s local file system.\nDo not print an all-in-one ticket\nWhere the data should be stored.\nReads from the provided path\nWrites to the provided path\nPrint an all-in-one ticket.\nProgress state for providing.\nEntry with a given name, size, and hash.\nGet a ticket to share this blob.\nReads from stdin\nData passed via STDIN.\nWrites to stdout\nWhether to print an all-in-one ticket.\nPossible outcomes of an input.\nValidate hashes on the running node.\nAdds data to iroh, either from a path or, if path is <code>None</code>, …\nAdds a <code>BlobSource</code> given some <code>BlobAddOptions</code>.\nCombines the <code>AddProgress</code> outputs from a <code>Stream</code> into a …\nChecks the consistency of the blobs on the running node, …\nOverride the filename used for the entry in the created …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdd in place\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDo not print the all-in-one ticket to get the added data …\nPrints out the add response.\nRuns the blob command given the iroh client.\nRuns a list subcommand.\nRuns the delete command.\nDisplays the download progress for a given stream.\nTag to tag the data with.\nDefine the tags subcommand.\nChecks the validity of the blobs on the running node, and …\nWrap the added file or directory in a collection.\nOptions to configure the address information in the …\nAdditional socket address to use to contact the node. Can …\nDisplay the contents of this ticket too.\nThe hash to export.\nHash of the blob to share.\nNodeId of the provider.\nDirectory or file in which to save the file(s).\nDirectory or file in which to save the file(s).\nIf set, the ticket’s direct addresses will not be used.\nIf set, will queue the download in the download queue.\nOverride to treat the blob as a raw blob or a hash …\nSet to true if the hash refers to a collection and you …\nIf the blob is a collection, the requester will also fetch …\nOverride the relay URL to use to contact the node.\nRepair the store by removing invalid data\nRepair the store by removing invalid data\nPath to a file or folder.\nIf set, the data will be moved to the output directory, …\nIf set, the data will be moved to the output directory, …\nTag to tag the data with.\nTicket or Hash to use.\nVerbosity level.\nVerbosity level.\nBlobs to delete\nDelete a tag\nList all tags\nCommands to manage tags.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRuns the tag command given the iroh client.\nAn error occurred that prevents the request from being …\nFailed to receive response from service.\nThe request was cancelled by us.\nThe download was cancelled by us\nThe request is already complete in the local store.\nConcurrency limits for the <code>Downloader</code>.\nType of connections returned by the Dialer.\nType of connections the Getter requires to perform a …\nTrait modeling a dialer. This allows for IO-less testing.\nError returned when a download could not be completed.\nFailed to download from any provider\nHandle to interact with a download request.\nThe kind of resource to download.\nA download request.\nHandle for the download services.\nAn error occurred that suggests the node should not be …\nSignals what should be done with the request when it fails.\nOutput returned from <code>Getter::get</code>.\nTrait modelling performing a single request over a …\nIdentifier for a download intent.\nTrait modelling the intermediary state when a connection …\nThe request needs a connection to continue.\nType of the intermediary state returned from <code>Self::get</code> if …\nNo provider nodes found\nConfiguration for retry behavior of the <code>Downloader</code>.\nAn error occurred in which neither the node nor the …\nCancel a download.\nGet the format of this download\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a future that checks the local store if the …\nGet the hash of this download\nGet the <code>HashAndFormat</code> pair of this download\nThe initial delay to wait before retrying a node. On …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a node is being dialed.\nMaximum number of nodes to dial concurrently for a single …\nMaximum number of requests the service performs …\nMaximum number of requests performed by a single node …\nMaximum number of open connections the service maintains.\nMaximum number of retry attempts for a node that failed to …\nCreate a new download request.\nCreate a new Downloader with the default <code>ConcurrencyLimits</code> …\nGet the node id of our node.\nDeclare that certain nodes can be used to download a hash.\nGet the number of dialing nodes.\nProceeds the download with the given connection.\nPass a progress sender to receive progress updates.\nQueue a download.\nDial a node.\nCreate a new Downloader with custom <code>ConcurrencyLimits</code> and …\nWe got an error and need to abort.\nWe are done with the whole operation.\nWe finished exporting a blob\nProgress events for an export operation\nThe download part is done for this id, we are now …\nWe have made progress exporting the data.\nExport a hash to the local file system.\nExport a single blob to a file on the local filesystem.\nExport all entries of a collection, recursively, to files …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe hash of the entry.\nUnique id of the entry.\nUnique id of the entry that is being exported.\nUnique id of the entry that is being exported.\nOperation-specific metadata.\nThe offset of the progress, in bytes.\nThe path to the file where the data is exported.\nThe size of the entry in bytes.\nThe collection type used by iroh\nA collection of blobs\nThe header for the collection format.\nA simple store trait for loading blobs\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if this collection is empty\nIterate over the blobs in this collection\nGet the number of blobs in this collection\nLoad a blob from the store\nCreate a new collection from a hash sequence and metadata.\nLoad a collection from a store given a root hash\nAdd the given blob to the collection.\nRead the collection from a get fsm.\nRead the collection and all it’s children from a get fsm.\nStore a collection in a store. returns the root hash of …\nConvert the collection to an iterator of blobs, with the …\nError when opening a stream\nError when decoding, e.g. hash mismatch\nA generic error\nError when processing a response\nError when reading from the stream\nStats about the transfer.\nError when writing the handshake or request to the stream\nThe number of bytes read\nThe number of bytes written\nFunctions that use the iroh-blobs protocol in conjunction …\nThe time it took to transfer the data\nError returned from get operations\nReturns the argument unchanged.\nReturns the argument unchanged.\nFinite state machine for get responses.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransfer rate in megabits per second\nTypes for get progress state management.\nUtilities for complex get requests.\nWe got an error and need to abort.\nAll operations finished.\nThe id of a blob in a transfer\nInformation about a the status of a blob in a store.\nA child blob (child id &gt; 0)\nThe requested data is completely available in the local …\nwe have the blob completely\nA new connection was established.\nWe are done with <code>id</code>.\nProgress updates for the get operation.\nAn item was found with hash <code>hash</code>, from now on referred to …\nAn item was found with hash <code>hash</code>, from now on referred to …\nData was found locally.\nOutput of <code>get_to_db_in_steps</code>.\nIntermediary state returned from <code>get_to_db_in_steps</code> for a …\nInitial state if subscribing to a running or queued …\nwe don’t have the blob at all\nThe requested data is not fully available in the local …\nwe have the blob partially\nWe got progress ingesting item <code>id</code>.\nThe root blob (child id 0)\nGet information about a blob in a store.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a blob or collection into a store.\nGet a blob or collection into a store, yielding if a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRanges that are missing locally and need to be requested.\nProceed with the download by providing a connection to a …\nThe size of the blob, if known.\nGiven a partial entry, get the valid ranges.\nRanges that are valid locally.\nThe partial entry.\nThe size of the entry in bytes.\nThe ranges that are available locally.\nchild offset\nIdentifier for this blob within this download.\nNumber of children in the collection, if known.\nThe hash of the entry.\nThe hash of the entry.\nThe name of the entry.\nA new unique progress id for this entry.\nThe unique id of the entry.\nThe unique id of the entry.\nThe offset of the progress, in bytes.\nThe size of the entry in bytes.\nThe size of the entry in bytes.\nThe ranges that are available locally.\nOur download request is invalid.\nFailures for a get operation\nNetwork or IO operation failed.\nOperation failed on the local node.\nRemote behaved in a non-compliant way.\nHash not found.\nRemote has reset the connection.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nState while we are reading content\nState before reading a size header\nError that you can get from <code>AtBlobHeader::next</code>\nState when finishing the get response\nState of the get response machine after the handshake has …\nState after we have read all the content for a blob\nInitial state of the get response machine\nState of the get response when we start reading a child\nState of the get response when we start reading a …\nThe next state after reading a content item\nQuic connection is closed.\nRequest is empty\nNo more children expected\nPossible next states after the handshake has been sent\nError that you can get from <code>AtConnected::next</code>\nDecode error that you can get once you have sent the …\nWe are done with this blob\nThe next state after the end of a blob\nA generic io error\nGeneric io error\nA generic io error\nThe hash of a leaf did not match the expected hash\nA parent was not found or invalid, so the provider stopped …\nWe expect more content\nResponse is expected to have more children\nEof when reading the size header\nA chunk was not found or invalid, so the provider stopped …\nThe hash of a parent did not match the expected hash\nA parent was not found or invalid, so the provider stopped …\nError when serializing the request\nQuinn read error when reading the size header\nError when reading from the stream\nThe serialized request is too long to be sent\nFirst response is a child\nFirst response is either a collection or a single blob\nError when writing the request to the <code>SendStream</code>.\nThe offset of the child we are currently reading\nConcatenate the entire response into a vec\nConcatenate the entire response into a vec\nDrain the response and throw away the result\nDrain the response and throw away the result\nFinish the get response without reading further\nFinish the get response without reading further\nImmediately finish the get response without reading further\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash of the root blob\nThe hash of the blob we are reading.\nThe hash of the blob we are reading.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new get response\nInitiate a new bidi stream to use for the get response\nSend the request and move to the next state\nGo into the next state, reading the header\nGo into the next state, reading the header\nRead the size header, returning it and going into the …\nRead the next item, either content, an error, or the end …\nRead the next child, or finish\nFinish the get response, returning statistics\nThe current offset of the blob we are reading.\nThe current offset of the blob we are reading.\nThe ranges we have requested for the child\nThe ranges we have requested for the child\nThe ranges we have requested for the current hash.\nThe entry point of the get response machine\nThe geometry of the tree we are currently reading.\nWrite the entire blob to a slice writer.\nWrite the entire blob to a slice writer.\nWrite the entire stream for this blob to a batch writer.\nWrite the entire stream for this blob to a batch writer.\nWrite the entire blob to a slice writer and to an optional …\nWrite the entire blob to a slice writer and to an optional …\nProgress state for a single blob\nState of a single blob in transfer\nDownload has finished\nDownload is pending\nThe identifier for progress events.\nDownload is in progress\nAccumulated progress state of a transfer.\nNumber of children (only applies to hashseqs, None for raw …\nChildren if the root blob is a hash seq, empty for raw …\nWhether we are connected to a node\nChild being transferred at the moment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a blob state by its <code>BlobId</code> in this transfer.\nGet the blob state currently being transferred.\nThe hash of this blob.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRanges already available locally at the time of starting …\nCreate a new, empty transfer state.\nCreate a new <code>BlobState</code>.\nUpdate the state with a new <code>DownloadProgress</code> event for …\nThe current state of the blob transfer.\nProgress ids for individual blobs.\nGet state of the root blob of this transfer.\nThe root blob of this transfer (may be a hash seq),\nThe size of this blob. Only known if the blob is partially …\nProbe for a single chunk of a blob.\nGiven a hash of a hash seq, get the hash seq and the …\nGet the claimed size of a blob from a peer.\nGet the verified size of a blob from a peer.\nGiven a sequence of sizes of children, generate a range …\nA sequence of links, backed by a <code>Bytes</code> object.\nIterator over the hashes in a <code>HashSeq</code>.\nStream over the hashes in a <code>HashSeq</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the hash at the given index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nGet the underlying bytes.\nCheck if this sequence is empty.\nIterate over the hashes in this sequence.\nGet the number of hashes in this sequence.\nCreate a new sequence of hashes.\nGet the next hash in the sequence.\nParse a sequence of hashes.\nGet and remove the first hash in this sequence.\nSkip a number of hashes in the sequence.\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nEnum of metrics for the module\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNewtype for a batch id\nA request to the node to download and share the data …\nStart the download right away.\nSet the mode for whether to directly start the download or …\nQueue the download.\nGet a client for the blobs protocol\nIf the format is <code>BlobFormat::HashSeq</code>, all children are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandle an RPC request\nThis mandatory field contains the hash of the data to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether to directly start the download or add it to the …\nThis mandatory field specifies the nodes to download the …\nOptional tag to tag the data with.\nThe ALPN used with quic for the iroh bytes protocol.\nReasons to close connections or stop streams.\nA <code>RangeSpec</code> selecting nothing from the blob.\nA get request for a blob or collection\nA request\nMaximum message size is limited to 100MiB for now.\nAn iterator over blobs in the sequence with a non-empty …\nThe provider is terminating.\nA chunk range specification as a sequence of chunk offsets.\nA chunk range specification for a sequence of blobs.\nA request to the provider\nThe provider has received the request.\nThe <code>RecvStream</code> was dropped.\nUnknown error_code, can not be converted into <code>Closed</code>.\nCreates a <code>RangeSpec</code> selecting the entire blob.\nA <code>RangeSpecSeq</code> containing all chunks from all blobs.\nRequest a collection and all its children\nIf this range seq describes a range for a single item, …\nA <code>RangeSpecSeq</code> containing no chunks from any blobs in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvenience function to create a <code>RangeSpecSeq</code> from a …\nConvenience function to create a <code>RangeSpecSeq</code> from a …\nblake3 hash\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nChecks if this <code>RangeSpec</code> selects all chunks in the blob.\nChecks if this <code>RangeSpec</code> does not select any chunks in the …\nAn infinite iterator of range specs for blobs in the …\nAn iterator over blobs in the sequence with a non-empty …\nRequest the last chunk of a single blob\nRequest the last chunk for all children\nCreates a new <code>RangeSpec</code> from a range set.\nCreates a new range spec sequence from a sequence of range …\nRequest a blob or collection with specified ranges\nThe range of data to request\nThe close reason as bytes. This is a valid utf8 string …\nRequest just a single blob\nCreates a <code>ChunkRanges</code> from this <code>RangeSpec</code>.\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nWe got an error and need to abort.\nWe got an error and need to abort.\nProgress updates for the add operation.\nWe are done with the whole operation.\nProgress updates for the batch add operation.\nA new client connected to the node.\nTrait for sending blob events.\nWe are done with <code>id</code>, and the hash is <code>hash</code>.\nWe are done, and the hash is <code>hash</code>.\nEvents emitted by the provider informing about the current …\nA sender for events related to blob transfers.\nAn item was found with name <code>name</code>, from now on referred to …\nAn item was found with the given size\nA request was received from a client.\nThe requested data was not found\nWe got progress ingesting item <code>id</code>.\nWe got progress ingesting the item.\nA helper struct that combines a quinn::SendStream with …\nThe requested data was sent\nStatus  of a send operation\nA new collection or tagged blob has been added\nA request was aborted because the client disconnected.\nA blob in a sequence was transferred.\nA request was completed and the data was sent to the …\nA sequence of hashes has been found and is being …\nA chunk of a blob was transferred.\nThe stats for a transfer of a collection or blob.\nThe total duration of the transfer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandle a single connection.\nHandle a single get request.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new event sender.\nStats for reading from disk.\nRead the request from the getter.\nSend an event and wait for it to be sent.\nSend an event.\nStats for sending to the client.\nSend a blob to the client.\nTry to send an event.\nTry to send an event.\nThe format of the added data.\nThe hash of the entry.\nThe hash of the created data.\nA new unique id for this entry.\nThe unique id of the entry.\nThe unique id of the entry.\nThe name of the entry.\nThe offset of the progress, in bytes.\nThe size of the entry in bytes.\nThe tag of the added data.\nThe hash of the entry.\nThe offset of the progress, in bytes.\nThe size of the entry in bytes.\nAn unique connection id.\nAn unique connection id.\nAn unique connection id.\nAn unique connection id.\nAn unique connection id.\nAn unique connection id.\nThe quic connection id.\nOffset up to which we have transferred data.\nThe format of the added data\nThe hash of the added data\nThe hash for which the client wants to receive data.\nThe hash for which we are transferring data.\nThe hash of the blob\nThe index of the blob in the sequence.\nThe number of blobs in the sequence.\nAn identifier uniquely identifying this transfer request.\nAn identifier uniquely identifying this transfer request.\nAn identifier uniquely identifying this transfer request.\nAn identifier uniquely identifying this transfer request.\nAn identifier uniquely identifying this transfer request.\nAn identifier uniquely identifying this request.\nThe size of the blob transferred.\nstatistics about the transfer\nstatistics about the transfer. This is None if the transfer\nThe tag of the added data\nIroh blobs and tags client\nRPC protocol for the iroh-blobs service\nAPI for blobs management.\nAPI for tag management.\nOptions for adding a directory as a collection\nOptions for adding a file as a blob\nOutcome of a blob add operation.\nProgress stream for blob add operations.\nOptions for adding a directory as a collection\nReads all available bytes.\nReads at most this many bytes.\nA batch for write operations.\nInformation about a complete blob.\nStatus information about a blob.\nIroh blobs client.\nInformation about a stored collection.\nThe blob is stored completely.\nStart the download right away.\nSet the mode for whether to directly start the download or …\nOptions to configure a download request.\nOutcome of a blob download operation.\nProgress stream for blob download operations.\nReads exactly this many bytes, erroring out on larger or …\nOutcome of a blob export operation.\nProgress stream for blob export operations.\nInformation about an incomplete blob.\nType alias for a memory-backed client.\nDo not wrap the file or directory.\nThe blob is not stored at all.\nThe blob is only stored partially.\nQueue the download.\nDefines the way to read bytes.\nData reader for a single blob.\nWrap the file or directory in a collection.\nWhether to wrap the added data in a collection.\nAdd a sequence of blobs, where the last is a hash sequence.\nWrite a blob by passing bytes.\nWrite a blob by passing bytes.\nWrite a blob by passing bytes, setting an explicit tag …\nWrite a blob by passing bytes.\nAdd a collection.\nAdd a directory as a hashseq in iroh collection format\nAdd a directory as a hashseq in iroh collection format\nImport a blob from a filesystem path, using the default …\nImport a blob from a filesystem path.\nImport a blob from a filesystem path.\nWrite a blob by passing an async reader.\nWrite a blob by passing an async reader.\nWrite a blob by passing an async reader.\nWrite a blob by passing a stream of bytes.\nWrite a blob by passing a stream of bytes.\nWrite a blob by passing a stream of bytes.\ntodo make private again\nCreate a new batch for adding data.\nSize of the chunks to send\nValidate hashes on the running node.\nCreate a collection from already existing blobs.\nDelete a blob.\nDownload a blob from another node and add it to the local …\nDownload a hash sequence from another node and add it to …\nDownload a blob, with additional options.\nThe size of the data we downloaded from the network\nThe size we expect\nExport a blob from the internal blob store to a path on …\nFinish writing the stream, ignoring all intermediate …\nFinish writing the stream, ignoring all intermediate …\nFinish writing the stream, ignoring all intermediate …\nThe format of the blob\nThe format of the blob\nThe format the blob\nThe format of the data to download.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ntodo make private again\nRead the content of a collection.\nCheck if a blob is completely stored on the node.\nThe hash of the blob\nHash of the collection\nThe hash of the blob\nThe hash of the blob\nThe import mode\nThe import mode\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIo parallelism\nWhether this blob has been downloaded completely.\nList all complete blobs.\nList all collections.\nList all incomplete (partial) blobs.\nThe size of the data we already had locally\nWhether to directly start the download or add it to the …\nCreate a new client\nCreate a <code>DownloadProgress</code> that can help you easily poll …\nCreate a <code>ExportProgress</code> that can help you easily poll the …\nSource nodes to download from.\nLocation of the blob\nUpgrades a temp tag to a persistent tag.\nUpgrades a temp tag to a persistent tag with a specific …\nUpgrades a temp tag to a persistent tag with either a …\nStream the contents of a a single blob.\nRead offset + len from a single blob.\nRead all bytes of single blob at <code>offset</code> for length <code>len</code>.\nRead all bytes of single blob.\nRead all bytes of the blob.\nTotal size of this blob.\nThe size of the blob\nThe size of the blob\nThe size we got\nStatistics about the download\nCheck if a blob is completely stored on the node.\nThe tag of the blob\nTag of the collection\nOptional tag to tag the data with.\nGet a tags client.\nCreates a temp tag to protect some content (blob or …\nNumber of children in the collection\nTotal size of the raw data referred to by all links\nValidate hashes on the running node.\nWhether to preserve the directory name\nThe size of the currently stored partial blob.\nThe size of the blob.\nOverride the filename in the wrapping collection.\nIroh tags client.\nInformation about a tag.\nDeletes a tag.\nFormat of the data\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash of the data\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLists all tags.\nLists all tags with a hash_seq format.\nName of the tag\nCreates a new client\nContains the error value\nContains the success value\nError type for RPC operations\nResult type for RPC operations\nquic-rpc service for iroh blobs\nRPC requests and responses for the blob service.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTags RPC protocol\nAbort the request due to an error on the client side\nAbort the request due to an error on the client side\nA request to the node to provide the data at the given path\nWrapper around <code>AddProgress</code>.\nWrite a blob from a byte stream\nWrapper around <code>AddProgress</code>.\nWrite a blob from a byte stream\nWrite a blob from a byte stream\nResponse to a batch add path request\nWrite a blob from a byte stream\nWrapper around <code>AddProgress</code>.\nWrite a blob from a byte stream\nRequest to create a new scope for temp tags\nResponse to a temp tag scope request\nCreate a temp tag with a given hash and format\nUpdate to a temp tag scope\nRequest to get the status of a blob\nThe response to a status request\nA chunk of stream data\nA chunk of stream data\nA request to the node to validate the integrity of all …\nCreate a collection.\nA response to a create collection request\nChunks of entry data.\nDelete a blob\nProgress response for <code>BlobDownloadRequest</code>\nDrop of a remote temp tag\nThe entry header.\nA request to the node to download and share the data …\nProgress response for <code>ExportRequest</code>\nWe got the id of the scope\nList all blobs, including collections\nList all blobs, including collections\nMessage to check that the connection is still alive\nGet the bytes for a hash\nResponse to <code>ReadAtRequest</code>\nA request to the node to validate the integrity of all …\nBatch to create the temp tag in\nBatch to create the temp tag in\nBatch to create the temp tag in\nThe collection\nContent to protect\nSet to <code>ExportFormat::Collection</code> if the <code>hash</code> refers to a …\nWhat format to use for the blob\nWhat format to use for the blob\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe hash of the blob to export.\nHash to get bytes for\nName of the tag\nThe resulting hash.\nThe hash of the blob\nAdd the data in place\nTrue if the provider can assume that the data will not …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength of the data to get\nThe mode of exporting.\nOffset to start reading at\nThe path to the data to provide.\nThe filepath to where the data should be saved\nThe path to the data to provide.\nrepair the store by dropping inconsistent blobs\nrepair the store by downgrading blobs from complete to …\nTag to tag the data with.\nTag to tag the data with.\nTag option.\nThe resulting tag.\nTags that should be deleted after creation.\nWhether to wrap the added data in a collection\nThe data chunk\nWhether the blob is complete\nThe size of the blob\nCreate a tag\nDelete a tag\nFully sync the db\nList all collections\nDo not sync the db\nSet or delete a tag\nDetermine how to sync the db after a modification operation\nList all tags\nBatch to use, none for global\nBatch to use, none for global\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nList hash seq tags\nList hash seq tags\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nName of the tag\nName of the tag\nList raw tags\nList raw tags\nSync mode\nSync mode\nValue of the tag\nValue of the tag, None to delete\nWe got an error and need to abort.\nWe got an error and need to abort.\nWe are done with the whole operation.\nAn async batch interface for writing bao content items to …\nThe size of a bao file\nThe hash refers to any blob and will be exported to a …\nThe hash refers to a <code>crate::format::collection::Collection</code> …\nThe entry is completely available.\nProgress updates for the validate operation\nThis mode will copy the file into the database before …\nThis mode will copy the file to the target directory.\nProgress when copying the file to the store\nA custom event (info)\nA custom event (debug)\nA custom non critical error\nA custom non critical error\nA fallible but owned iterator over the entries in a store.\nDone exporting\nConsistency check ended\nWe started validating a complete entry\nThe entry type. An entry is a cheaply cloneable handle …\nWe are done with <code>id</code>\nAn entry that is possibly writable\nWe got progress ingesting item <code>id</code>.\nThe availability status of an entry in a store.\nAn unrecoverable error during GC\nAn unrecoverable error during GC\nErrors, something is very wrong\nDatabase events\nThe expected format of a hash being exported.\nThe import mode describes how files will be imported.\nExport trogress callback\nFound a path\nA GC was completed\nConfiguration for the GC mark and sweep.\nAn event related to GC\nA GC was started\nAn event related to GC\nThe import mode describes how files will be imported.\nProgress messages for an import operation\nInfo messages\nA generic map from hashes to bao blobs (blobs with bao …\nAn entry for one hash in a bao map\nA partial entry\nA mutable bao map.\nThe entry is not in the store.\nDone computing the outboard\nProgress when computing the outboard\nThe entry is partially available.\nWe started validating an entry\nWe are done with <code>id</code>\nWe got progress ingesting item <code>id</code>.\nProgress when copying the file to the target\nExtension of <code>Map</code> to add misc methods used by the rpc calls.\nLevel for generic validation messages\nDetermined the size\nStarting to export to a file\nConsistency check started\nstarted validating\nThe mutable part of a Bao store.\nVery unimportant info messages\nThis mode will try to reference the file in place and …\nThis mode will try to move the file to the target …\nA remote side told us the size, but we have insufficient …\nConsistency check update\nProgress updates for the validate operation\nWe have verified the size.\nWarnings, something is not quite right\nGet a batch writer\nlist all blobs in the database. This includes both raw …\nPerform a consistency check on the database\nCreate a new tag\nA future that resolves to a reader that can be used to …\nphysically delete the given hashes from the store.\nAn optional callback called every time a GC round finishes.\nFind out if the data behind a <code>hash</code> is complete, partial, …\nSync version of <code>entry_status</code>, for the doc sync engine …\nThis trait method extracts a file to a local path.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nredb backed storage\nStart the GC loop\nGet an entry for a hash.\nGet an existing entry as an EntryMut.\nGet an existing partial entry, or create a new one.\nThe hash of the entry.\nImport data from memory.\nThis trait method imports a file from a local path.\nImport data from an async byte reader.\nImport data from a stream of bytes.\nUpgrade a partial entry to a complete entry.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the entry is complete.\nA full in memory database for iroh-blobs\nCreate a new <code>BaoFileSize</code> with the given size and …\nA future that resolves to a reader that can be used to …\nlist partial blobs in the database\nThe period at which to execute the GC.\nA readonly in memory database for iroh-blobs, usable for …\nSet a tag\nShutdown the store.\nThe size of the entry.\nSync the written data to permanent storage, if applicable. …\nSync the store.\nlist all tags (collections or other explicitly added …\nCreate a temporary pin for this store\nTemp tags\nValidate the database\nGet just the value, no matter if it is verified or not.\nWrite a batch of bao content items to the underlying …\nThe entry this message is about, if any\nThe level of the message\nThe message\nAn error if we failed to validate the entry.\nthe hash of the entry\nthe hash of the entry\na new unique id for this entry\nThe unique id of the entry.\nThe unique id of the entry.\na new unique id for this entry\nThe unique id of the entry.\nThe unique id of the entry.\nThe offset of the progress, in bytes.\nThe offset of the progress, in bytes.\nlocation of the entry.\nlocation of the entry.\nAvailable ranges.\nThe size of the entry, in bytes.\nThe best known size of the entry, in bytes.\nThe total number of entries to validate\nDefines a Bao tree.\nA block size.\nA set of byte ranges\nA number of blake3 chunks.\nA set of chunk ranges\nA referenceable set of chunk ranges\nAn offset of a node in a post-order outboard\nthe node is stable and won’t change when appending data\nAn u64 that defines a node in a bao tree.\nthe node is unstable and will change when appending data\nThe default block size, 1024 bytes\nConvert a node to a node in a tree with a larger block size\nThe block size of the tree\nNumber of blocks in the tree\nNumber of bytes in a block at this level\nGet the log2 of the number of 1 KiB blocks in a chunk.\nGet the range of blocks this node covers\nnumber of chunks that this number of bytes covers\nNumber of chunks in the tree\nNumber of nodes below this node, excluding this node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCompute a block size from bytes\nCreate a block size from the log2 of the size in bytes / …\nnumber of chunks that this number of bytes covers\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplementation of bao streaming for std io and tokio io\nTrue if this is a leaf node.\nIterators over BaoTree nodes\nGet the left child of this node, or None if it is a child …\nThe level of the node in the tree, 0 for leafs.\nthe middle of the tree node, in blocks\nCreate a new self contained BaoTree\nGet the next left ancestor of this node, or None if there …\nGet the range of nodes this node covers\nThe outboard size for this tree.\nUnrestricted parent, can only be None if we are at the top\nTraverse the entire tree in post order as BaoChunks\nTraverse the entire tree in post order as TreeNodes, down …\nThe offset of the given node in the post order traversal\nGet the post order offset of this node\nGet the range of post order offsets this node covers\nTraverse the entire tree in pre order as TreeNodes, down …\nThe offset of the given node in the pre order traversal\nTraverse the part of the tree that is relevant for a …\nRestricted parent, will be None if we call parent on the …\nGet the right child of this node, or None if it is a child …\nthe number of times you have to go right from the root to …\nRoot of the tree\nThe size of the blob from which this tree was constructed, …\nConvert a node to a node in a tree with a smaller block …\nnumber of bytes that this number of chunks covers\nConvert to usize or panic if it doesn’t fit.\nJust get the offset value, ignoring whether it’s stable …\nAn output of the default size, 32 bytes, which provides …\nAn incremental hash state that can accept any number of …\nThe error type for <code>Hash::from_hex</code>.\nThe number of bytes in a key, 32.\nThe number of bytes in a <code>Hash</code>, 32.\nAn incremental reader for extended output, returned by …\nThe raw bytes of the <code>Hash</code>. Note that byte arrays don’t …\nReturn the total number of bytes hashed so far.\nThe key derivation function.\nExecutes the given command directly.\nFill a buffer with output bytes and advance the position …\nFinalize the hash state and return the <code>Hash</code> of the input.\nFinalize the hash state and return an <code>OutputReader</code>, which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Hash</code> from its raw bytes representation.\nDecode a <code>Hash</code> from hexadecimal. Both uppercase and …\nThe default hash function.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe keyed hash function.\nConstruct a new <code>Hasher</code> for the regular hash function.\nConstruct a new <code>Hasher</code> for the key derivation function. See\nConstruct a new <code>Hasher</code> for the keyed hash function. See …\nReturn the current read position in the output stream. …\nQueues the given command for further execution.\nReset the <code>Hasher</code> to its initial state.\nSeek to a new read position in the output stream. This is …\nPerforms a set of actions within a synchronous update.\nEncode a <code>Hash</code> in lowercase hexadecimal.\nAdd input bytes to the hash state. You can call this any …\nThis is equivalent to <code>update</code>.\nA content item for the bao streaming protocol.\nError when decoding from a reader, after the size has been …\nError when encoding from outboard and data\nThere was an error reading from the underlying io\nThere was an error reading from the underlying io\nA leaf node.\na leaf node, to write to the file\nThe hash of a leaf did not match the expected hash\nThe hash of a leaf did not match the expected hash\nWe got an EOF while reading a chunk, indicating that the …\nWe got a ConnectionReset while writing a chunk, indicating …\nA parent hash pair.\na parent node, to update the outboard\nThe hash of a parent did not match the expected hash\nThe hash of a parent did not match the expected hash\nWe got an EOF while reading a parent hash pair, indicating …\nWe got a ConnectionReset while writing a parent hash pair, …\nFile size does not match size in outboard\nThe data of the leaf.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAsync io, written in fsm style\nGiven a range set of byte ranges, round it up to chunk …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe node in the tree for which the hashes are.\nThe byte offset of the leaf in the file.\nImplementations of the outboard traits\nThe pair of hashes for the node.\nGiven a range set of byte ranges, round it up to full …\nSync IO operations\nA trait to abstract async reading from different resource.\nA trait to abstract async writing to different resources.\nA content item for the bao streaming protocol.\nConvenience trait to initialize an outboard from a data …\nThe stream is done, you get back the underlying reader\na leaf node, to write to the file\nOne more item, and you get back the state machine in the …\nA binary merkle tree for blake3 hashes of a blob.\nA mutable outboard.\na parent node, to update the outboard\nResponse decoder\nNext type for ResponseDecoder.\nCopy an outboard to another outboard.\nCreate an outboard from a seekable data source, measuring …\ncreate an outboard from a data source. This requires the …\nDecode a response into a file while updating an outboard.\nEncode ranges relevant to a query from a reader and …\nEncode ranges relevant to a query from a reader and …\nImmediately return the underlying reader\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash of the blob we are currently getting\nInit the outboard from a data source. This will use the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nload the hash pair for a node\nCreate a new response decoder state machine, when you have …\nProceed to the next state by reading the next chunk from …\nCompute the outboard for the given data.\nCompute the post order outboard for the given data, …\nRead the entire buffer at the given position.\nThe root hash\nSave a hash pair for a node\nSet the length of the underlying storage.\nGet the length of the resource\nSync any buffers to the underlying storage.\nsync to disk\nThe tree. This contains the information about the size of …\nThe tree geometry\nGiven just an outboard, compute all valid ranges.\nGiven a data file and an outboard, compute all valid …\nWrite the entire slice at the given position.\nWrite the entire Bytes at the given position.\nAn empty outboard, that just returns 0 hashes for all …\nA post order outboard that is optimized for memory storage.\nA generic outboard in post order\nA pre order outboard that is optimized for memory storage.\nA generic outboard in pre order\nCreate a new outboard from <code>data</code> and a <code>block_size</code>.\nCreate a new outboard from <code>data</code> and a <code>block_size</code>.\nhashes with length prefix\nhashes with length prefix\nhashes without length suffix\nhashes with length prefix\nFlip the outboard to pre order.\nFlip the outboard to a post order outboard.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nreturns the outboard data, with the length prefix added.\nreturns the outboard data, with the length suffix.\nMap the outboard data to a new type.\nMap the outboard data to a new type.\nroot hash\nroot hash\nroot hash\nroot hash\nroot hash\ntree defining the geometry\ntree defining the data\ntree defining the data\ntree defining the data\ntree defining the data\nConvenience trait to initialize an outboard from a data …\nIterator that can be used to decode a response to a range …\nA binary merkle tree for blake3 hashes of a blob.\nA mutable outboard.\nTrait for reading bytes at an offset.\nTrait to get the size in bytes of an I/O object.\nTrait for writing bytes at an offset.\nGet a reference to the buffer used for decoding.\nCopy an outboard to another outboard.\nCreate an outboard from a data source.\ncreate an outboard from a data source. This requires the …\nDecode a response into a file while updating an outboard.\nEncode ranges relevant to a query from a reader and …\nEncode ranges relevant to a query from a reader and …\nFlush this writer, ensuring that any intermediately …\nReturns the argument unchanged.\nInit the outboard from a data source. This will use the …\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nload the hash pair for a node\nCreate a new iterator to decode a response.\nCreate a new iterator to decode a response.\nCompute the outboard for the given data.\nCompute the post order outboard for the given data, …\nReads bytes from an offset in this source into a buffer, …\nReads the exact number of bytes required to fill <code>buf</code> from …\nThe root hash\nSave a hash pair for a node\nGet the size of this object, in bytes.\nSync the outboard.\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nThe tree. This contains the information about the size of …\nGet a reference to the tree used for decoding.\nGiven just an outboard, compute all valid ranges.\nGiven a data file and an outboard, compute all valid …\nWrites a complete buffer at an offset.\nWrites bytes from a buffer to an offset, returning the …\nA chunk describeds what to read or write next\nexpect data of size <code>size</code>\nexpect a 64 byte parent node.\nIterator over all chunks in a BaoTree in post-order.\nIterator over all nodes in a tree in post-order.\nIterator over all nodes in a BaoTree in pre-order.\nIterator over all nodes in a BaoTree in pre-order that …\nThe owned version of <code>ResponseIterRef</code>.\nAn iterator that produces chunks in pre order.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nGet the minimum level to always emit, even if the node is …\nCreate a new iterator over the tree.\nCreate a new iterator given a root node and a len\nCreate a new iterator given a root node and a len\nCreate a new iterator over the tree.\nCreate a new iterator over the tree.\nCreate a new iterator over the tree.\nReturn the size of the chunk in bytes.\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nThe tree this iterator is iterating over.\nGet a reference to the tree.\nReturn the underlying tree.\nSet the ranges to the unit value\nThis is the root, to be passed to parent_cv\nThis is the root, to be passed to hash_block\nPush the left hash to the stack, since it will be needed …\nThe tree node, useful for error reporting\nAdditional information about what part of the chunk …\nAdditional information about what part of the chunk …\nPush the right hash to the stack, since it will be needed …\nSize of the data to expect. Will be chunk_group_bytes for …\nStart chunk, to be passed to hash_block\nAlways inline everything\nOptions for transaction batching.\nUse BaoFileHandle as the entry type for the map.\nOptions for inlining small complete data or outboards.\nDo not inline anything, ever.\nOptions for the file store.\nOptions for directories used by the file store.\nStorage that is using a redb database for small files and …\nTransaction batching options.\nPath to the directory where data and outboard files are …\nDump the entire content of the database to stdout.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInline storage options.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad or create a new store.\nMaximum data size to inline.\nMaximum outboard size to inline.\nMaximum number of actor messages to batch before creating …\nMaximum duration to wait before committing a read …\nMaximum number of actor messages to batch before …\nMaximum duration to wait before committing a write …\nCreate a new store with custom options.\nOwned data path\nOwned outboard path\nPath options.\nPath to the directory where temp files are stored. This …\nTransform all entries in the store. This is for testing …\nUpdate the inline options.\nAn in memory entry\nA fully featured in memory database for iroh-blobs, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new in memory store\nA set of non-overlapping ranges\nA range set that stores up to 2 boundaries inline\nA reference to a range set\na range set containing all values\nThe boundaries of the range set, guaranteed to be strictly …\ntrue if the value is contained in the range set\ndifference\ndifference in place\nthe empty range set\nCreate a new range set reference for an empty range set\nReturns the argument unchanged.\nintersection\nintersection in place\ntrue if this range set intersects from another range set\nCalls <code>U::from(self)</code>.\nget the boundaries in this range set as a SmallVec\ntrue if the range set contains all values\ntrue if this range set is disjoint from another range set\ntrue if the range set is empty\ntrue if this range set is a superset of another range set\ntrue if this range set is a subset of another range set\niterate over all ranges in this range set\niterate over all ranges in this range set\ncreate a new range set from the given boundaries\nCreate a new range set reference\nCreate a new range set reference without checking that the …\nCreate a new range set reference without checking that the …\nA set of non-overlapping ranges\nCreate a new range set reference for a single value\nSplit this range set into two parts <code>left</code>, <code>right</code> at …\nsymmetric difference (xor)\nsymmetric difference in place (xor)\nunion\nunion in place\nIterator for the ranges in a range set\nClosed range\nRange with unbounded end\nA set of non-overlapping ranges\nA range set that stores up to 2 boundaries inline\ntrait for types that can be entries of range sets\nRange that can be part of a range set\nA reference to a range set\nMaps a <code>RangeSetRange&lt;&amp;T&gt;</code> to a <code>RangeSetRange&lt;T&gt;</code> by cloning …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nchecks if this is the minimum value\nthe minimum value for this type\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nThe MapEntry implementation for Store.\nA readonly in memory database for iroh-blobs.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the bytes associated with a hash, if they exist.\nimport a byte slice\nInsert a new entry into the database, and return the hash …\nInsert multiple entries into the database, and return the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new Store from a sequence of entries.\nA tag will be automatically generated\nA file\nWe got it all in memory\nThis is a general purpose Either, just like Result, except …\nThe tag is explicitly named\nOption for commands that allow setting a tag\nA file that is sparse in memory\nA tag\nA trait for things that can track liveness of blobs and …\nTrait used from temp tags to notify an abstract store that …\nA hash and format pair that is protected from garbage …\nTurn a reference to a MemOrFile into a MemOrFile of …\nGet this as a weak reference for use in temp tags\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUtilities for filesystem operations.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the data and the valid ranges\nUtilities for working with tokio io\nTrue if this is a Mem\nA local task pool with proper shutdown\nMap the file part of this MemOrFile\nMap the memory part of this MemOrFile\nGet the mem part\nCreate a new, empty SparseMemFile\nCalled on creation of a temp tag\nCalled on drop\nPersist the SparseMemFile to a WriteAt\nUtilities for reporting progress.\nGet the size of the MemOrFile\nCreate a new temp tag for the given hash and format\nGet the number of bytes given a set of chunk ranges and …\nTry to map the file part of this MemOrFile\nA data source\nInformation about the content on a path\nThis function converts an already canonicalized path to a …\ntotal number of files in the directory\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHelper function that translates a key that was derived …\nLoads a <code>iroh_net::key::SecretKey</code> from the provided file, …\nReturns blob name for this data source.\nCreates a new <code>DataSource</code> from a <code>PathBuf</code>.\nReturns the path of this data source.\nWalks the directory to get the total size and number of …\nHelper function that creates a document key from a …\nThis function converts a canonicalized relative path to a …\nCreate data sources from a directory.\nCreate data sources from a path.\ntotal size of all the files in the directory\nCreates a new <code>DataSource</code> from a <code>PathBuf</code> and a custom name.\nA reader that tracks the number of bytes read\nA writer that tracks the number of bytes written\nGet the number of bytes read\nGet the number of bytes written\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the inner reader\nGet the inner writer\nWrap a reader in a tracking reader\nWrap a writer in a tracking writer\nTask was dropped, either due to a panic or because the …\nLocal task pool configuration\nA local task pool with proper shutdown\nA handle to a <code>LocalPool</code>\nLog the panic and continue\nWhat to do when a panic occurs in a pool thread\nFuture returned by <code>LocalPoolHandle::spawn</code> and …\nLog the panic and immediately shut down the pool.\nErrors for spawn failures\nAbort the task\nA future that resolves when the pool is cancelled\nGently shut down the pool\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a cheaply cloneable handle to the pool\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new local pool with the given config.\nIgnore panics in pool threads\nImmediately stop polling all tasks and wait for all …\nCreate a new local pool with a single std thread.\nSpawn a task in the pool and await the result.\nSpawn a task in the pool.\nPrefix for thread names\nNumber of threads in the pool\nSpawn a task in the pool and return a future that resolves …\nSpawn a task in the pool.\nSpawn a task in the pool.\nGet the number of tasks in the queue\nA progress sender that uses an async channel.\nA boxed progress sender\nContains the error value\nA slice writer that adds a fallible progress callback.\nAn id generator, to be combined with a progress sender.\nA no-op progress sender.\nThe message being sent.\nContains the success value\nAn error that can occur when sending progress messages.\nA result type for progress sending.\nA general purpose progress sender. This should be usable …\nA slice writer that adds a synchronous progress callback.\nThe receiver was dropped.\nTransform the message type by filter-mapping to the type …\nTransform the message type by mapping to the type of this …\nSend a message and block if the receiver is full.\nCreate a boxed progress sender to get rid of the concrete …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the inner writer\nReturn the inner writer.\nCreate a new progress sender from an async channel sender.\nCreate a new <code>ProgressSliceWriter</code> from an inner writer and …\nCreate a new <code>ProgressSliceWriter</code> from an inner writer and …\nGet a new unique id\nReturns true if <code>other</code> sends on the same <code>async_channel</code> …\nSend a message and wait if the receiver is full.\nTry to send a message and drop it if the receiver is full.\nTransform the message type by filter-mapping to the type …\nTransform the message type by mapping to the type of this …\nDocument handle\nAn iroh client.\nIroh rpc client - boxed so that we can have a concrete …\nThe RPC service for the iroh provider process.\nAPI for document management.\nReturns the docs client.\nAPI for blobs management.\nReturns the blobs client.\nConnects to an iroh node at the given RPC address.\nConnects to an iroh node running on the same computer, but …\nAPI for document management.\nReturns the docs client.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIroh gossip client.\nReturns the gossip client.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAPI to manage the iroh networking stack.\nReturns the net client.\nCreates a new high-level client to a Iroh node from the …\nClient to interact with an iroh node.\nReturns the net client.\nAPI for tag management.\nReturns the tags client.\nA node connected to us and we accepted the exchange\nIroh docs client.\nWe initiated the exchange\nDirect join request via API\nPeer showed up as new neighbor in the gossip swarm\nWhy we performed a sync exchange\nWe received a sync report while a sync was running, so run …\nEvent emitted when a sync operation completes\nWhy we started a sync request\nWe synced after receiving a sync report that indicated …\nTimestamp when the sync started\nOrigin of the sync exchange\nPeer we synced with\nResult of the sync operation\nTimestamp when the sync finished\nOptions for adding a directory as a collection\nOptions for adding a file as a blob\nOutcome of a blob add operation.\nProgress stream for blob add operations.\nOptions for adding a directory as a collection\nReads all available bytes.\nReads at most this many bytes.\nA batch for write operations.\nInformation about a complete blob.\nStatus information about a blob.\nIroh blobs client.\nInformation about a stored collection.\nThe blob is stored completely.\nStart the download right away.\nSet the mode for whether to directly start the download or …\nOptions to configure a download request.\nOutcome of a blob download operation.\nProgress stream for blob download operations.\nReads exactly this many bytes, erroring out on larger or …\nOutcome of a blob export operation.\nProgress stream for blob export operations.\nInformation about an incomplete blob.\nType alias for a memory-backed client.\nDo not wrap the file or directory.\nThe blob is not stored at all.\nThe blob is only stored partially.\nQueue the download.\nDefines the way to read bytes.\nData reader for a single blob.\nWrap the file or directory in a collection.\nWhether to wrap the added data in a collection.\nSize of the chunks to send\nThe size of the data we downloaded from the network\nThe size we expect\nThe format of the blob\nThe format of the blob\nThe format the blob\nThe format of the data to download.\nThe hash of the blob\nHash of the collection\nThe hash of the blob\nThe hash of the blob\nThe import mode\nThe import mode\nIo parallelism\nThe size of the data we already had locally\nWhether to directly start the download or add it to the …\nSource nodes to download from.\nLocation of the blob\nThe size of the blob\nThe size of the blob\nThe size we got\nStatistics about the download\nThe tag of the blob\nTag of the collection\nOptional tag to tag the data with.\nNumber of children in the collection\nTotal size of the raw data referred to by all links\nWhether to preserve the directory name\nThe size of the currently stored partial blob.\nThe size of the blob.\nOverride the filename in the wrapping collection.\nWe got an error and need to abort.\nA node connected to us and we accepted the exchange\nWe are done setting the entry to the doc.\nIroh docs client.\nWe initiated the exchange\nThe content of an entry was downloaded and is now …\nDirect join request via API\nDocument handle\nA single entry in a <code>Replica</code>\nOutcome of a <code>Doc::export_file</code> operation\nProgress stream for <code>Doc::export_file</code>.\nAn item was found with name <code>name</code>, from now on referred to …\nOutcome of a <code>Doc::import_file</code> operation\nProgress stream for <code>Doc::import_file</code>.\nProgress messages for an doc import operation\nWe are done adding <code>id</code> to the data store and the hash is …\nA local insertion.\nReceived a remote insert.\nEvents informing about actions of the live sync progress.\nType alias for a memory-backed client.\nWe lost a neighbor in the swarm.\nWe have a new neighbor in the swarm.\nPeer showed up as new neighbor in the gossip swarm\nWhy we performed a sync exchange\nAll pending content is now ready.\nWe got progress ingesting item <code>id</code>.\nRead-only access\nWe received a sync report while a sync was running, so run …\nIntended capability for document share tickets\nEvent emitted when a sync operation completes\nA set-reconciliation sync finished.\nWhy we started a sync request\nWe synced after receiving a sync report that indicated …\nWrite access\nTimestamp when the sync started\nThe hash of the entry’s content\nThe key of the entry\nOrigin of the sync exchange\nThe path to which the entry was saved\nPeer we synced with\nResult of the sync operation\nThe size of the entry\nThe size of the entry\nTimestamp when the sync finished\nThe hash of the entry.\nA new unique id for this entry.\nThe unique id of the entry.\nThe unique id of the entry.\nThe key of the entry\nThe name of the entry.\nThe offset of the progress, in bytes.\nThe size of the entry in bytes.\nIf the content is available at the local node\nThe inserted entry.\nThe inserted entry.\nThe peer that sent us the entry.\nThe content hash of the newly available entry content\nIroh gossip client.\nType alias for a memory-backed client.\nOptions for subscribing to a gossip topic.\nBootstrap nodes to connect to.\nSubscription capacity.\nIroh net Client.\nThe response to a version request\nAdds a known node address to this node.\nThe node id and socket addresses of this node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the relay server we are connected to.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe bound listening addresses of the node\nCreates a new net client\nFetches the <code>NodeAddr</code> for this node.\nFetches the node id of this node.\nFetches node information about a remote iroh node …\nFetches information about currently known remote nodes.\nRPC address, if currently listening.\nThe version of the node\nClient to interact with an iroh node.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new node client\nShuts down the node.\nFetches statistics of the running node.\nFetches status information about this node.\nIroh tags client.\nInformation about a tag.\nFormat of the data\nHash of the data\nName of the tag\nAuthor key to insert entries in a <code>crate::Replica</code>\nTimestamps of the latest entry for each author.\n<code>AuthorPublicKey</code> in bytes\nIdentifier for an <code>Author</code>\nEntry signature is invalid.\nThe capability of the namespace.\nErrors for capability operations\nKind of capability of the namespace.\nThe replica is closed, no operations may be performed.\nThe content is completely available.\nWhether the content status is available on a node.\nCallback that may be set on a replica to determine the …\nContains both a key (either secret or public) to a …\nA single entry in a <code>Replica</code>\nAttempted to insert an empty entry.\nSignature over an entry.\nEvent emitted by sync when entries are added.\nThe content is partially available.\nError emitted when inserting entries into a <code>Replica</code> failed\nWhether an entry was inserted locally or by a remote peer.\nEntry has length 0 but not the empty hash, or the empty …\nEntry namespace does not match the current replica.\nThe entry was inserted locally.\nA local entry has been added.\nMax time in the future from our wall clock time that we …\nThe content is missing.\n<code>NamespacePublicKey</code> in bytes\nNamespaces are not the same\nThe corresponding <code>VerifyingKey</code> for a <code>NamespaceSecret</code>. It …\nNamespace key of a <code>crate::Replica</code>.\nA newer entry exists for either this entry’s key or a …\nByte representation of a <code>PeerId</code> from <code>iroh-net</code>.\nProtocol message for the set reconciliation protocol.\nA readable replica.\nRead only access to the namespace.\nError that occurs trying to access the <code>NamespaceSecret</code> of …\nReplica is read only.\nThe data part of an entry in a <code>Replica</code>.\nThe identifier of a record.\nA remote entry has been added.\nLocal representation of a mutable, synchronizable …\nIn memory information about an open replica.\nA signed entry.\nStorage error\nThe entry was received from the remote node identified by …\nOutcome of a sync operation.\nEntry timestamp is too far in the future.\nValidation failure\nReason why entry validation failed\nA writable replica.\nWrite access to the namespace.\nThis contains an actor spawned on a separate thread to …\nGet this <code>RecordIdentifier</code> as a tuple of byte slices.\nGet this <code>RecordIdentifier</code> as Bytes.\nGet the byte representation of this <code>AuthorId</code>.\nGet the byte representation of this <code>NamespaceId</code>.\nConvert to byte slice.\nConvert to byte slice.\nGet the <code>AuthorId</code> of this entry.\nGet the <code>AuthorId</code> of this record as byte array.\nGet the author bytes of this entry.\nGet the <code>Capability</code> of this <code>Replica</code>.\neither a public or private key\nDefine commands for interacting with documents in Iroh.\nReturns true if the replica is closed.\nGet the content <code>Hash</code> of the entry.\nGet the content hash of the record.\nGet the <code>Hash</code> of the content data of this record.\nGet the content length of the entry.\nGet the content length of the record.\nGet the length of the data addressed by this record’s …\nDecode from byte slice created with <code>Self::encode</code>.\nDelete entries that match the given <code>author</code> and key <code>prefix</code>.\nCreate a tombstone record (empty content)\nCreate a tombstone record with the timestamp set to now.\nSerialize this entry into its canonical byte …\nEncode into a byte array with a limited size.\nHandlers and actors to for live syncing replicas.\nGet the <code>Entry</code>.\nConvert to a base32 string limited to the first 10 bytes …\nConvert to a base32 string limited to the first 10 bytes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>Author</code> from a byte array.\nCreate from a slice of bytes.\nCreate a <code>NamespaceSecret</code> from a byte array.\nCreate from a slice of bytes.\nCreate a new signed entry by signing an entry with the …\nCreate a new signature by signing an entry with the …\nCreate a new signed entries from its parts.\nCreate a <code>Capability</code> from its raw representation.\nGet the timestamp for an author.\nCan this state offer newer stuff to <code>other</code>?\nHashes the given data and inserts it.\nTimestamp of the latest entry for each author in the set …\nGet the <code>NamespaceId</code> for this <code>Capability</code>.\nGet the namespace identifier for this <code>Replica</code>.\nGet the <code>RecordIdentifier</code> for this entry.\nGet the <code>AuthorId</code> for this author.\nGet the <code>NamespaceId</code> for this namespace.\nInsert a new record at the given key.\nInsert a new timestamp.\nInsert an entry into this replica which was received from …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into <code>NamespacePublicKey</code>.\nConvert into <code>AuthorPublicKey</code>.\nReturn <code>true</code> if the entry is empty.\nWhether this <code>AuthorHeads</code> is empty.\nCreate an iterator over the entries in this state.\nGet the key of the entry.\nGet the key of this entry.\nGet the key of this record.\nGet the key of this record as <code>Bytes</code>.\nGet the kind of capability.\nNumber of author-timestamp pairs.\nMerge this capability with another capability.\nMerge another author head state into this one.\nMerge a capability.\nMetrics for iroh-docs\nGet the <code>NamespaceId</code> of this entry.\nGet the <code>NamespaceId</code> of this record as byte array.\nNetwork implementation of the iroh-docs protocol\nCreate a new doc ticket\nCreate a new replica.\nCreate a new replica.\nCreate a new entry\nCreate a new <code>RecordIdentifier</code>.\nCreate a new record.\nCreate a new <code>Author</code> with a random key.\nCreate a new <code>NamespaceSecret</code> with a random key.\nCreate a new <code>Record</code> with the timestamp set to now.\nCreate a new empty entry with the current timestamp.\nA list of nodes to contact.\nNumber of entries we received.\nNumber of entries we sent.\n<code>ProtocolHandler</code> implementation for the docs <code>Engine</code>.\nGet the <code>AuthorPublicKey</code> for this author.\nGet the <code>NamespacePublicKey</code> for this namespace.\nConvert into <code>NamespacePublicKey</code> by fetching from a …\nConvert into <code>AuthorPublicKey</code> by fetching from a …\nGet the raw representation of this namespace capability.\nGet the <code>Record</code> contained in this entry.\nGet the identifier for an entry in this replica.\nQuic RPC implementation for docs.\nGet the <code>NamespaceSecret</code> of this <code>Capability</code>. Will fail if …\nGet the byte representation of the <code>NamespaceSecret</code> key for …\nSet the content status callback.\nSign this entry with a <code>NamespaceSecret</code> and <code>Author</code>.\nSign a message with this <code>Author</code> key.\nSign a message with this <code>NamespaceSecret</code> key.\nGet the signature.\nStorage trait and implementation for iroh-docs documents\nSubscribe to insert events.\nGet the number of current event subscribers.\nAPI for iroh-docs replicas\nCreate the initial message for the set reconciliation flow …\nProcess a set reconciliation message from a remote peer.\nGet the timestamp of the entry.\nGet the timestamp of the record.\nGet the timestamp of this record.\nGet this <code>RecordIdentifier</code> as a tuple of bytes.\nReturns the <code>Author</code> byte representation.\nReturns the <code>NamespaceSecret</code> byte representation.\nConvert to byte array.\nConvert to byte array.\nSerialize this entry into a new vector with its canonical …\nExplicitly unsubscribe a sender.\nValidate that the entry has the empty hash if the length …\nValidate that the entry has the empty hash if the length …\nVerify the signatures on this entry.\nVerify that this signature was created by signing the <code>entry</code>…\nStrictly verify a signature on a message with this <code>Author</code>…\nVerify that a signature matches the <code>msg</code> bytes and was …\nStrictly verify a signature on a message with this …\nVerify that a signature matches the <code>msg</code> bytes and was …\nInserted entry.\nInserted entry.\nPeer that provided the inserted entry.\nDocument in which the entry was inserted.\nDocument in which the entry was inserted.\n<code>ContentStatus</code> for this entry in the remote’s replica.\nWhether download policies require the content to be …\nThe peer from which we received this entry.\nWhether the peer claims to have the content blob for this …\nOptions when opening a replica.\nThe state for an open replica.\nThe <code>SyncHandle</code> controls an actor thread which executes …\nMakes sure that all pending database operations are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBy how many handles the replica is currently held open\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpawn a sync actor and return a handle.\nSubscribe to replica events.\nOptionally subscribe to replica events.\nHow many event subscriptions are open\nSet sync state to true.\nWhether to accept sync requests for this replica.\nSet to true to set sync state to true.\nSort by author, then key\nDisplays the content if small enough, otherwise it …\nEnvironment for CLI and REPL\nDisplay the content unconditionally.\nCreate a new document.\nDelete all entries below a key prefix.\nDifferent modes to display content.\nSet the download policies for a document.\nSubcommands for the download policy command.\nPossible <code>Document</code> commands.\nDelete a document from the local node.\nDownload everything in this document.\nExport the most recent data for a key from a document\nGeneral download policy for a document.\nGet entries in a document.\nDisplay the hash of the content.\nImport data into a document\nJoin a document from a ticket.\nSort by key, then author\nList all keys in a document.\nStop syncing a document.\nList documents.\nDownload nothing in this document.\nSet an entry in a document.\nShare a document with peers.\nDisplay the shortened hash of the content.\nHow to sort.\nSet the active document (only works within the Iroh …\nWatch for changes and events on a document\nGet the active author.\nDefine the commands to manage authors.\nGet the active document.\nRead only from environment variables.\nRead from environment variables and the console config …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the iroh data directory\nRuns the document command given the iroh client and the …\nDocument to operate on.\nDocument to operate on.\nAdd an exception to the download policy. An exception must …\nSet the general download policy for this document.\nOptions to configure the address information in the …\nAuthor of the entry.\nFilter by author.\nAuthor of the entry.\nAuthor of the entry.\nFilter by author.\nSort in descending order\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nDocument to operate on.\nIf true, don’t copy the file into iroh, reference the …\nKey to the entry (parsed as UTF-8 string).\nKey to the entry (parsed as UTF-8 string).\nKey to the entry (parsed as UTF-8 string)\nThe sharing mode.\nHow to show the contents of the key.\nHow to show the contents of the keys.\nWhen true, you will not get a prompt to confirm you want …\nPath to export to\nPath to a local file or directory to import\nIf true, get all entries that start with KEY.\nPrefix to delete. All entries whose key starts with or is …\nPrefix to add to imported entries (parsed as UTF-8 …\nOptional key prefix (parsed as UTF-8 string)\nHow to sort the entries\nSwitch to the created document (only in the Iroh console).\nSwitch to the joined document (only in the Iroh console).\nContent to store for this entry (parsed as UTF-8 string)\nCommands to manage authors.\nCreate a new author.\nPrint the default author for this node.\nDelete an author.\nExport an author.\nImport an author.\nList authors.\nSet the active author (Note: only works within the Iroh …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRuns the author command given an iroh client and console …\nSwitch to the created author (Note: only works in the Iroh …\nSwitch to the default author (Note: only works in the Iroh …\nA node connected to us and we accepted the exchange\nWe initiated the exchange\nThe content of an entry was downloaded and is now …\nPersistent default author for a docs engine.\nWhere to persist the default author.\nDirect join request via API\nThe sync engine coordinates actors that manage open …\nA local insertion.\nReceived a remote insert.\nEvents informing about actions of the live sync progress.\nMemory storage.\nWe lost a neighbor in the swarm.\nWe have a new neighbor in the swarm.\nPeer showed up as new neighbor in the gossip swarm\nWhy we performed a sync exchange\nAll pending content is now ready.\nFile based persistent storage.\nWe received a sync report while a sync was running, so run …\nEvent emitted when a sync operation completes\nA set-reconciliation sync finished.\nWhy we started a sync request\nWe synced after receiving a sync report that indicated …\nGet the blob store.\nGet an in memory client to interact with the docs engine.\nThe persistent default author for this engine.\n<code>Endpoint</code> used by the engine.\nConverts an <code>EntryStatus</code> into a [‘ContentStatus’].\nTimestamp when the sync started\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current default author.\nHandle an incoming iroh-docs connection.\nHandle a docs request from the RPC server.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStop the live sync for a document and leave the gossip …\nLoad the default author from the storage.\nLoad the default author from storage.\nOrigin of the sync exchange\nPeer we synced with\nSave a new default author.\nResult of the sync operation\nSet the default author.\nShutdown the engine.\nStart the sync engine.\nStart to sync a document.\nTimestamp when the sync finished\nSubscribe to replica and sync progress events.\nHandle to the actor thread.\nIf the content is available at the local node\nThe inserted entry.\nThe inserted entry.\nThe peer that sent us the entry.\nThe content hash of the newly available entry content\nMetrics for iroh-docs\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWe aborted the sync request.\nReason why we aborted an incoming sync request.\nErrors that may occur on handling incoming sync …\nWhether we want to accept or reject an incoming sync …\nAccept the sync request.\nWe are already syncing this namespace.\nFailed to close\nFailed to close\nFailed to establish connection\nFailed to establish connection\nErrors that may occur on outgoing sync requests.\nThe ALPN identifier for the iroh-docs protocol\nWe experienced an error while trying to provide the …\nNamespace is not available.\nFailed to open replica\nDecline the sync request\nThe remote peer aborted the sync request.\nFailed to run sync\nFailed to run sync\nDetails of a finished sync operation.\nTime a sync operation took\nTime to establish connection\nConnect to a peer and sync a replica\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandle an iroh-docs connection and sync all shared …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the namespace (if available)\nThe namespace that was synced.\nThe outcome of the sync operation\nGet the peer’s node ID (if available)\nThe peer we syned with.\nTime to run sync exchange\nThe time this operation took\nRPC Client for docs and authors\nProtocol definitions for RPC.\nAPI for document management.\nAPI for document management.\nA node connected to us and we accepted the exchange\nIroh docs client.\nWe initiated the exchange\nDirect join request via API\nPeer showed up as new neighbor in the gossip swarm\nWhy we performed a sync exchange\nWe received a sync report while a sync was running, so run …\nEvent emitted when a sync operation completes\nWhy we started a sync request\nWe synced after receiving a sync report that indicated …\nCreates a new document author.\nReturns the default document author of this node.\nDeletes the given author by id.\nExports the given author.\nTimestamp when the sync started\nReturns the argument unchanged.\nImports the given author.\nCalls <code>U::from(self)</code>.\nLists document authors for which we have a secret key.\nCreates a new docs client.\nOrigin of the sync exchange\nPeer we synced with\nResult of the sync operation\nSets the node-wide default author.\nTimestamp when the sync finished\nWe got an error and need to abort.\nA node connected to us and we accepted the exchange\nWe are done setting the entry to the doc.\nIroh docs client.\nWe initiated the exchange\nThe content of an entry was downloaded and is now …\nDirect join request via API\nDocument handle\nA single entry in a <code>Replica</code>\nOutcome of a <code>Doc::export_file</code> operation\nProgress stream for <code>Doc::export_file</code>.\nAn item was found with name <code>name</code>, from now on referred to …\nOutcome of a <code>Doc::import_file</code> operation\nProgress stream for <code>Doc::import_file</code>.\nProgress messages for an doc import operation\nWe are done adding <code>id</code> to the data store and the hash is …\nA local insertion.\nReceived a remote insert.\nEvents informing about actions of the live sync progress.\nType alias for a memory-backed client.\nWe lost a neighbor in the swarm.\nWe have a new neighbor in the swarm.\nPeer showed up as new neighbor in the gossip swarm\nWhy we performed a sync exchange\nAll pending content is now ready.\nWe got progress ingesting item <code>id</code>.\nRead-only access\nWe received a sync report while a sync was running, so run …\nIntended capability for document share tickets\nEvent emitted when a sync operation completes\nA set-reconciliation sync finished.\nWhy we started a sync request\nWe synced after receiving a sync report that indicated …\nWrite access\nReturns an authors client.\nCloses the document.\nCreates a client.\nDeletes entries that match the given <code>author</code> and key <code>prefix</code>.\nDeletes a document from the local node.\nExports an entry as a file to a given absolute path.\nFinishes writing the stream, ignoring all intermediate …\nIterates through the export progress stream, returning …\nTimestamp when the sync started\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the download policy for this document\nReturns an entry for a key and author.\nReturns all entries matching the query.\nReturns a single entry.\nReturns sync peers for this document\nThe hash of the entry’s content\nReturns the document id of this doc.\nImports a document from a ticket and joins all peers in …\nImports a document from a ticket, creates a subscription …\nAdds an entry from an absolute file path\nImports a document from a namespace capability.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe key of the entry\nStops the live sync for this document.\nLists all documents.\nCreates a new docs client.\nReturns a <code>Doc</code> client for a single document.\nOrigin of the sync exchange\nThe path to which the entry was saved\nPeer we synced with\nResult of the sync operation\nSets the content of a key to a byte array.\nSets the download policy for this document\nSets an entries on the doc via its key, hash, and size.\nShares this document with peers over a ticket.\nThe size of the entry\nThe size of the entry\nStarts to sync this document with a list of peers.\nTimestamp when the sync finished\nReturns status info for this document\nSubscribes to events for this document.\nThe hash of the entry.\nA new unique id for this entry.\nThe unique id of the entry.\nThe unique id of the entry.\nThe key of the entry\nThe name of the entry.\nThe offset of the progress, in bytes.\nThe size of the entry in bytes.\nIf the content is available at the local node\nThe inserted entry.\nThe inserted entry.\nThe peer that sent us the entry.\nThe content hash of the newly available entry content\nCreate a new document author.\nResponse for <code>AuthorCreateRequest</code>\nDelete an author\nResponse for <code>AuthorDeleteRequest</code>\nExports an author\nResponse for <code>AuthorExportRequest</code>\nGet the default author.\nResponse for <code>AuthorGetDefaultRequest</code>\nImport author from secret key\nResponse to <code>ImportRequest</code>\nList document authors for which we have a secret key.\nResponse for <code>AuthorListRequest</code>\nSet the default author.\nResponse for <code>AuthorSetDefaultRequest</code>\nOpen a document\nResponse to <code>CloseRequest</code>\nCreate a new document\nResponse to <code>CreateRequest</code>\nDelete entries in a document\nResponse to <code>DelRequest</code>\nList all documents\nSubscribe to events for a document.\nResponse to <code>DocSubscribeRequest</code>\nStop the live sync for a doc, and optionally delete the …\nResponse to <code>DropRequest</code>\nA request to the node to save the data of the entry to the …\nProgress messages for an doc export operation\nGet a download policy\nResponse to <code>GetDownloadPolicyRequest</code>\nGet entries from a document\nResponse to <code>GetExactRequest</code>\nGet entries from a document\nResponse to <code>GetManyRequest</code>\nGet peers for document\nResponse to <code>GetSyncPeersRequest</code>\nA request to the node to add the data at the given …\nWrapper around <code>ImportProgress</code>.\nImport a document from a capability.\nResponse to <code>ImportRequest</code>\nStop the live sync for a doc, and optionally delete the …\nResponse to <code>LeaveRequest</code>\nResponse to <code>DocListRequest</code>\nOpen a document\nResponse to <code>OpenRequest</code>\nThe RPC service type for the docs protocol.\nSet a download policy\nResponse to <code>SetDownloadPolicyRequest</code>\nSet an entry in a document via its hash\nResponse to <code>SetHashRequest</code>\nSet an entry in a document\nResponse to <code>SetRequest</code>\nShare a document with peers over a ticket.\nThe response to <code>ShareRequest</code>\nStart to sync a doc with peers.\nResponse to <code>StartSyncRequest</code>\nGet info on a document\nResponse to <code>StatusRequest</code>\nConfiguration of the addresses in the ticket.\nAuthor matcher\nThe id of the author to delete\nThe id of the author to delete\nThe author\nThe author to import\nAuthor of this entry.\nAuthor of this entry.\nAuthor of this entry.\nAuthor of this entry.\nThe author id\nThe id of the created author\nThe id of the author\nThe id of the author\nThe author id of the imported author\nThe capability over the document.\nThe namespace capability.\nThe document id\nthe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id.\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe document id\nThe newly-created entry.\nThe entry you want to export\nThe document entry\nThe document entry\nThe event that occurred on the document\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash of this entry.\nThe document id\nThe document id\nTrue if the provider can assume that the data will not …\nWhether to include empty entries (prefix deletion markers)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKey of this entry.\nKey of this entry.\nKey of this entry.\nKey matcher\nWhether to share read or write access to the document\nThe mode of exporting. Setting to <code>ExportMode::TryReference</code> …\nThe filepath to the data\nThe filepath to where the data should be saved\nList of peers to join\nList of peers ids\nDownload policy\nThe download policy\nPrefix to delete.\nQuery to run\nThe number of entries that were removed.\nSize of this entry.\nLive sync status\nValue of this entry.\nMatches any key.\nMatches any author.\nSort ascending\nAuthor matching.\nSort by author, then key.\nSort descending\nDownload policy to decide which content blobs shall be …\nStore that gives read access to download policies for a …\nDownload every key unless it matches one of the filters.\nMatches if the contained bytes and the key are the same.\nOnly keys that are exactly the provided value.\nMatches exactly the provided author.\nFilter strategy used in download policies.\nQuery on all entries without aggregation.\nOutcome of <code>Store::import_namespace</code>\nThe namespace did not exist before and is now inserted.\nSort by key, then author.\nKey matching.\nIn-memory key storage\nThe namespace existed and its capability remains unchanged.\nThe replica does not exist.\nDo not download any key unless it matches one of the …\nError return from <code>Store::open_replica</code>\nOther error while opening the replica.\nMatches if the contained bytes are a prefix of the key.\nAll keys that start with the provided value.\nStore trait for expanded public keys for authors and …\nNote: When using the <code>SingleLatestPerKey</code> query kind, the …\nA query builder for document queries.\nQuery that only returns the latest entry for a key which …\nFields by which the query can be sorted\nSort direction\nManages the replicas and authors for an instance.\nThe namespace existed and now has an upgraded capability.\nQuery all records.\nFilter by author.\nCreate a <code>Query::all</code> query filtered by a single author.\nConvert a <code>AuthorId</code> into a <code>AuthorPublicKey</code>.\nBuild the query.\nBuild the query.\nClose a replica.\nGet all content hashes of all replicas in the store.\nDelete an author.\nFlush the current transaction, if any.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nOn disk storage for replicas.\nGet an author key from the store.\nGet the download policy for a document.\nGet the download policy for a namespace.\nGet an entry by key and author.\nGet the latest entry for each author in a namespace.\nGet an iterator over entries of a replica.\nGet the peers that have been useful for a document.\nCheck if a <code>AuthorHeads</code> contains entry timestamps that we …\nImport an author key pair.\nImport a new replica namespace.\nCall to include empty entries (deletion markers).\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFilter by exact key match.\nCreate a <code>Query::all</code> query filtered by a single key.\nFilter by key prefix.\nCreate a <code>Query::all</code> query filtered by a key prefix.\nSet the maximum number of entries to be returned.\nGet the limit for this query (max. number of entries to …\nList all author keys in this store.\nList all replica namespaces in this store.\nLoad the replica info from the store.\nCheck if an entry should be downloaded according to this …\nVerifies whether this filter matches a given key\nTest if a key is matched by this <code>KeyFilter</code>.\nTest if an author is matched by this <code>AuthorFilter</code>.\nCreate a new store in memory.\nConvert a <code>NamespaceId</code> into a <code>NamespacePublicKey</code>.\nCreate a new author key and persist it in the store.\nCreate a new replica for <code>namespace</code> and persist in this …\nSet the offset within the result set from where to start …\nGet the offset for this query (number of entries to skip …\nOpen a replica from this store.\nCreate or open a store from a <code>path</code> to a database file.\nConvert a byte array into a  <code>VerifyingKey</code>.\nRegister a peer that has been useful to sync a document.\nRemove a replica.\nSet the download policy for a namespace.\nQuery only the latest entry for each key, omitting older …\nGet a read-only snapshot of the database.\nGet an owned read-only snapshot of the database.\nSet the sort for the query.\nSet the order direction for the query.\nIterator for all content hashes\nIterator over the latest entry per author.\nIterator over parent entries, i.e. entries with the same …\nAn iterator over a range of entries from the records table.\nManages the replicas and authors for an instance.\nA wrapper around <code>Store</code> for a specific <code>NamespaceId</code>\nCreate a new iterator over all content hashes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of anything into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nConvert an iterator of <code>Result</code>s into <code>FallibleIterator</code> by …\nTimestamps of the latest entry for each author.\nEntry signature is invalid.\nThe capability of the namespace.\nErrors for capability operations\nKind of capability of the namespace.\nThe replica is closed, no operations may be performed.\nThe content is completely available.\nWhether the content status is available on a node.\nCallback that may be set on a replica to determine the …\nA single entry in a <code>Replica</code>\nAttempted to insert an empty entry.\nSignature over an entry.\nEvent emitted by sync when entries are added.\nThe content is partially available.\nError emitted when inserting entries into a <code>Replica</code> failed\nWhether an entry was inserted locally or by a remote peer.\nEntry has length 0 but not the empty hash, or the empty …\nEntry namespace does not match the current replica.\nThe entry was inserted locally.\nA local entry has been added.\nMax time in the future from our wall clock time that we …\nThe content is missing.\nNamespaces are not the same\nA newer entry exists for either this entry’s key or a …\nByte representation of a <code>PeerId</code> from <code>iroh-net</code>.\nProtocol message for the set reconciliation protocol.\nA readable replica.\nRead only access to the namespace.\nError that occurs trying to access the <code>NamespaceSecret</code> of …\nReplica is read only.\nThe data part of an entry in a <code>Replica</code>.\nThe identifier of a record.\nA remote entry has been added.\nLocal representation of a mutable, synchronizable …\nIn memory information about an open replica.\nA signed entry.\nStorage error\nThe entry was received from the remote node identified by …\nOutcome of a sync operation.\nEntry timestamp is too far in the future.\nValidation failure\nReason why entry validation failed\nA writable replica.\nWrite access to the namespace.\nTimestamp of the latest entry for each author in the set …\nNumber of entries we received.\nNumber of entries we sent.\nInserted entry.\nInserted entry.\nPeer that provided the inserted entry.\nDocument in which the entry was inserted.\nDocument in which the entry was inserted.\n<code>ContentStatus</code> for this entry in the remote’s replica.\nWhether download policies require the content to be …\nThe peer from which we received this entry.\nWhether the peer claims to have the content blob for this …\nIroh gossip client.\nThe RPC service type for the gossip protocol\nDefine the gossiping subcommands.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMetrics for iroh-gossip\nNetworking for the <code>iroh-gossip</code> protocol\nCreates a new gossip client.\nImplementation of the iroh-gossip protocol, as an IO-less …\nProvides a rpc protocol as well as a client for the …\nSubscribes to a gossip topic with default options.\nSubscribes to a gossip topic.\nCommands to manage gossiping.\nSubscribe to a gossip topic\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRuns the gossip command given the iroh client.\nThe set of nodes that are also part of the gossip swarm to …\nThe raw topic to subscribe to as hex. Needs to be 32 …\nThe topic to subscribe to.\nIf enabled, all gossip events will be printed, including …\nEnum of metrics for the module\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBroadcast a message for this topic.\nBroadcast a message to all nodes in the swarm\nBroadcast a message to all direct neighbors\nSend a gossip message\nA stream of commands for a gossip subscription.\nEvents emitted from a gossip topic with a lagging …\nALPN protocol name\nPublish and subscribe on gossiping topics.\nWe received an event.\nEvents emitted from a gossip topic.\nReceiver for gossip events on a topic.\nSender for a gossip topic.\nSubscribed gossip topic.\nJoin this topic and connect to peers.\nOptions for joining a gossip topic.\nConnect to a set of peers\nWe joined the topic with at least one peer.\nWe missed some messages because our <code>GossipReceiver</code> was not …\nA gossip message\nWe dropped direct neighbor in the swarm membership layer …\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nWe have a new, direct neighbor in the swarm membership …\nCommands for the gossip protocol\nEvents emitted from the gossip protocol\nLeave this topic and drop all state.\nA gossip message was received for this topic\nWe received a gossip message for this topic.\nThe initial bootstrap nodes\nBroadcast a message to all nodes.\nSends a message to all peers.\nBroadcast a message to our direct neighbors.\nSends a message to our direct neighbors in the swarm.\nGet an in-memory gossip client\nThe content of the message\nThe node that delivered the message. This is not the same …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSpawn a gossip actor and get a handle for it\nHandle an incoming <code>Connection</code>.\nHandle a gossip request from the RPC server.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if we are connected to at least one node.\nReturns true if we are connected to at least one node.\nJoin a gossip topic with the default options and wait for …\nJoin a set of peers.\nJoin a gossip topic with options.\nJoin a gossip topic with options and an externally-created …\nWaits until we are connected to at least one node.\nWaits until we are connected to at least one node.\nGet the maximum message size configured for this gossip …\nLists our current direct neighbors.\nThe scope of the message. This tells us if the message is …\nSplits <code>self</code> into <code>GossipSender</code> and <code>GossipReceiver</code> parts.\nThe maximum number of messages that can be buffered in a …\nUtilities for iroh-gossip networking\nCreates <code>JoinOptions</code> with the provided bootstrap nodes and …\nA <code>TimerMap</code> with an async method to wait for the next timer …\nReturns the argument unchanged.\nInsert a new entry at the specified instant\nCalls <code>U::from(self)</code>.\nCreate a new timer map\nReads a length prefixed message.\nRead a length-prefixed message and decode as <code>ProtoMessage</code>;\nWait for the next timer to expire and return an iterator …\nWrite a <code>ProtoMessage</code> as a length-prefixed, …\nBroadcast a message for this topic.\nA command to the protocol state for a particular topic.\nExecute a command from the application.\nProtocol configuration\nThe scope to deliver the message to.\nClose the connection to a peer on the network level.\nEmit an event to the application.\nAn event to be emitted to the application for a particular …\nA trait for a concrete type to push <code>OutEvent</code>s to.\nInput event to the protocol state.\nJoin this topic and connect to peers.\nProtocol wire message\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nThis message was received from a direct neighbor that …\nThe message is broadcast only to the immediate neighbors …\nOutput event from the protocol state.\nOpaque binary data that is transmitted on messages that …\nUpdated peer data\nPeer disconnected on the network level.\nThe identifier for a peer.\nLeave this topic and drop all state.\nA gossip message was received for this topic\nMessage received from the network.\nSchedule a timer. The runtime is responsible for sending …\nThe broadcast scope of a gossip message.\nSend a message on the network\nThe state of the <code>iroh-gossip</code> protocol.\nThis message was received from the swarm, with a distance …\nThe message is broadcast to all peers in the swarm.\nA timer to be registered into the runtime\nTrigger a previously scheduled timer.\nThe identifier for a topic\nUpdate the opaque peer data about yourself.\nGet as byte slice.\nGet the peer data as a byte slice.\nConfiguration for the gossip broadcast layer\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from a byte array.\nHandle an <code>InEvent</code>\nCheck if a topic has any active (connected) peers.\nGet a reference to the contained <code>bytes::Bytes</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this message was directly received from its …\nGet the kind of this message\nReturns the maximum message size configured in the gossip …\nMax message size in bytes.\nGet a reference to the node’s <code>PeerIdentity</code>\nConfiguration for the swarm membership layer\nCreate a new protocol state instance.\nCreate a new <code>PeerData</code> from a byte buffer.\nPush an event in the IO container\nPush all events from an iterator into the IO container\nGet the encoded size of this message\nThe protocol state of the <code>iroh-gossip</code> protocol.\nGet a reference to the protocol state for a topic.\nGet an iterator for the states of all joined topics.\nThis module contains the implementation of the gossiping …\nGet an iterator of all joined topics.\nUtilities used in the protocol implementation\nExecute a command from the application.\nA control message.\nA data message.\nClose the connection to a peer on the network level.\nEmit an event to the application.\nInput event to the protocol state.\nProtocol wire message\nWhether this is a control or data message\nOutput event from the protocol state.\nUpdated peer data\nPeer disconnected on the network level.\nMessage received from the network.\nSchedule a timer. The runtime is responsible for sending …\nSend a message on the network\nThe state of the <code>iroh-gossip</code> protocol.\nA timer to be registered into the runtime\nTrigger a previously scheduled timer.\nThe identifier for a topic\nUpdate the opaque peer data about yourself.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBroadcast a message for this topic.\nA command to the protocol state for a particular topic.\nExecute a command from the application.\nProtocol configuration\nThe default maximum size in bytes for a gossip message. …\nClose the connection to a peer on the network level.\nEmit an event to the application.\nAn event to be emitted to the application for a particular …\nA message of the gossip broadcast layer\nA timer for the gossip layer\nA trait for a concrete type to push <code>OutEvent</code>s to.\nInput event to the topic state handler.\nJoin this topic and connect to peers.\nA protocol message for a particular topic\nWe dropped direct neighbor in the swarm membership layer …\nWe have a new, direct neighbor in the swarm membership …\nAn output event from the state handler.\nEmitted when new <code>PeerData</code> was received for a peer.\nPeer disconnected on the network level.\nLeave this topic and drop all state.\nA gossip message was received for this topic\nMessage received from the network.\nSchedule a timer. The runtime is responsible for sending …\nSend a message on the network\nThe topic state maintains the swarm membership and …\nStatistics for the protocol state of a topic\nA message of the swarm membership layer\nA timer for the swarm layer\nA timer to be registered for a particular topic.\nTrigger a previously scheduled timer.\nUpdate the opaque peer data about yourself.\nConfiguration for the gossip broadcast layer\nThe address of your local endpoint.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet statistics for the gossip broadcast state\nHandle an incoming event.\nCheck if this topic has any active (connected) peers.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the kind of this message\nMax message size in bytes.\nConfiguration for the swarm membership layer\nNumber of messages received\nNumber of messages sent\nInitialize the local state with the default random number …\nPush an event in the IO container\nPush all events from an iterator into the IO container\nGet stats on how many messages were sent and received\nInitialize the local state with a custom random number …\nA hash map where entries expire after a time\nA <code>BTreeMap</code> with <code>Instant</code> as key. Allows to process expired …\nReturns <code>true</code> if the map contains a value for the specified …\nRemove and return all entries before and equal to <code>from</code>.\nRemove all entries with an expiry instant lower or equal …\nGet the expiration time for an item.\nGet a reference to the earliest entry in the TimerMap.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet an item from the cache.\nInsert a new entry at the specified instant.\nInsert an item into the cache, marked with an expiration …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the map contains no elements.\nIterate over all items in the timer map.\nIterate over all items in the cache.\nGet the number of entries in the cache.\nCreate a new, empty TimerMap.\nRemove an entry from the specified instant.\nRemove an item from the cache.\nBroadcast a message to all nodes in the swarm\nBroadcast a message to all direct neighbors\nWe received an event.\nConnect to a set of peers\nWe missed some messages because our <code>GossipReceiver</code> was not …\nEvents emitted from a gossip topic with a lagging …\nSend a gossip message\nIroh gossip client.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe RPC protocol between client and node\nIroh gossip client.\nType alias for a memory-backed client.\nOptions for subscribing to a gossip topic.\nBootstrap nodes to connect to.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSubscription capacity.\nBroadcast a message to all nodes in the swarm\nBroadcast a message to all direct neighbors\nWe received an event.\nConnect to a set of peers\nWe missed some messages because our <code>GossipReceiver</code> was not …\nThe RPC service type for the gossip protocol\nA request to the node to subscribe to gossip events.\nEvents emitted from a gossip topic with a lagging …\nSend a gossip message\nThe nodes to bootstrap the subscription from\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe capacity of the subscription\nThe topic to subscribe to\nEnum of metrics for the module\nReturns the argument unchanged.\nCollect the current metrics into a hash map.\nCalls <code>U::from(self)</code>.\nInitialize the global metrics collection.\nNetwork paths to contact an iroh-net node.\nUse a custom relay map.\nUse the default relay map, with production relay servers …\nDisable relay servers completely.\nControls an iroh-net node, establishing connections with …\nNetwork-level addressing information for an iroh-net node.\nThe identifier for a node in the (iroh) network.\nConfiguration of all the relay servers that can be used.\nConfiguration of the relay servers for an <code>Endpoint</code>.\nInformation on a specific relay server.\nA URL identifying a relay server.\nUse the staging relay servers from n0.\nAccepts an incoming connection on the endpoint.\nInforms this <code>Endpoint</code> about addresses of the iroh-net node.\nInforms this <code>Endpoint</code> about addresses of the iroh-net …\nApplies the options to <code>self</code>.\nApplies the options to <code>self</code>.\nReturns the local socket addresses on which the underlying …\nReturns the builder for an <code>Endpoint</code>, with a production …\nCloses the QUIC endpoint and the magic socket.\nReturns a stream that reports connection type changes for …\nConnects to a remote <code>Endpoint</code>.\nConnects to a remote endpoint, using just the nodes’s …\nIs this a known node?\nCreates a new <code>RelayMap</code> with a single relay server …\nDefault values used in <code>iroh-net</code>\nA dialer to conveniently dial many nodes.\nReturns the direct addresses of this peer.\nReturns the direct addresses of this <code>Endpoint</code>.\nSocket addresses where the peer might be reached directly.\nNode address discovery.\nReturns the discovery mechanism, if configured.")