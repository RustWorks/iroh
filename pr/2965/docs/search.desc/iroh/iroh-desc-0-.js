searchState.loadedDescShard("iroh", 0, "Peer-to-peer QUIC connections.\nNetwork paths to contact an iroh node.\nOptions to configure what is included in a <code>NodeAddr</code> and …\nIncludes the Node ID and the direct addresses.\nOnly the Node ID is added.\nNetwork-level addressing information for an iroh node.\nThe identifier for a node in the (iroh) network.\nIncludes the Node ID and the relay URL.\nIncludes the Node ID and both the relay URL, and the …\nConfiguration of all the relay servers that can be used.\nInformation on a specific relay server.\nA URL identifying a relay server.\nApplies the options to <code>self</code>.\nApplies the options to <code>self</code>.\nIs this a known node?\nCreates a new <code>RelayMap</code> with a single relay server …\nDefault values used in <code>iroh</code>\nA dialer to conveniently dial many nodes.\nReturns the direct addresses of this peer.\nSocket addresses where the peer might be reached directly.\nNode address discovery.\nThis module exports a DNS resolver, which is also the …\nCreate an empty relay map.\nThe <code>Endpoint</code> allows establishing connections to other iroh …\nReturns the argument unchanged.\nReturns the addressing info from given ticket.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs the <code>RelayMap</code> from an iterator of <code>RelayNode</code>s.\nCreates a new <code>NodeAddr</code> from its parts.\nReturns a <code>RelayMap</code> from a <code>RelayUrl</code>.\nGet the given node.\nThe blake3 hash used in Iroh.\nAddressing information to connect to <code>Self::node_id</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this addressing information is empty.\nAre there any nodes in this map?\nCryptographic key handling for <code>iroh</code>.\nHow many nodes are known?\nCo-locating all of the iroh metrics structs\nCreates a new <code>NodeAddr</code> with empty <code>AddrInfo</code>.\nThe node’s identifier.\nReturns an <code>Iterator</code> over all known nodes.\nTools for spawning an accept loop that routes incoming …\nConfiguration to speak to the QUIC endpoint on the relay …\nReturns the relay url of this peer.\nThe node’s home relay url.\nWhether this relay server should only be used for STUN …\nThe stun port of the relay server.\nInternal utilities to support testing.\nTLS configuration based on libp2p TLS specs.\nThe <code>RelayUrl</code> where this relay server can be dialed.\nReturns the sorted relay URLs.\nAdds the given direct addresses to the peer’s <code>AddrInfo</code>.\nAdds a relay url to the node’s <code>AddrInfo</code>.\nThe default HTTPS port used by the Relay server.\nThe default HTTP port used by the Relay server.\nThe default metrics port used by the Relay server.\nThe default QUIC port used by the Relay server to accept …\nThe default STUN port used by the Relay server.\nProduction configuration.\nStaging configuration.\nHostname of the default Asia-Pacific relay.\nHostname of the default EU relay.\nHostname of the default NA relay.\nGet the default <code>RelayNode</code> for Asia-Pacific\nGet the default <code>RelayNode</code> for EU.\nGet the default <code>RelayNode</code> for NA.\nGet the default <code>RelayMap</code>.\nHostname of the default EU relay.\nHostname of the default NA relay.\nGet the default <code>RelayNode</code> for EU.\nGet the default <code>RelayNode</code> for NA.\nGet the default <code>RelayMap</code>.\nDials nodes and maintains a queue of pending dials.\nAborts a pending dial.\nReturns a reference to the endpoint used in this dialer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nChecks if a node is currently being dialed.\nCreate a new dialer for a <code>Endpoint</code>\nWaits for the next dial operation to complete.\nNumber of pending connections to be opened.\nStarts to dial a node by <code>NodeId</code>.\nA discovery service that combines multiple discovery …\nNode discovery for <code>super::Endpoint</code>.\nThe results returned from <code>Discovery::resolve</code>.\nAdds a <code>Discovery</code> service.\nThe address info for the node being resolved.\nDNS node discovery for iroh\nCreates an empty <code>ConcurrentDiscovery</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>ConcurrentDiscovery</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOptional timestamp when this node address info was last …\nA discovery service that uses an mdns-like service to …\nThe <code>NodeId</code> whose address we have discovered\nA discovery service which publishes and resolves node …\nA static string to identify the discovery source.\nPublishes the given <code>AddrInfo</code> to the discovery mechanism.\nResolves the <code>AddrInfo</code> for the given <code>NodeId</code>.\nA static discovery implementation that allows adding info …\nSubscribe to all addresses that get <em>passively</em> discovered.\nDNS node discovery\nThe n0 testing DNS node origin, for production.\nThe n0 testing DNS node origin, for testing.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new DNS discovery using the <code>iroh.link</code> domain.\nCreates a new DNS discovery.\nDiscovery using <code>swarm-discovery</code>, a variation on mdns\nName of this discovery service.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new <code>LocalSwarmDiscovery</code> Service.\nDefault TTL for the records in the pkarr signed packet.\nInterval in which to republish the node info even if …\nThe production pkarr relay run by number 0.\nThe testing pkarr relay run by number 0.\nPublisher of node discovery information to a pkarr relay.\nA pkarr client to publish <code>pkarr::SignedPacket</code>s to a pkarr …\nResolver of node discovery information from a pkarr relay.\nPkarr based node discovery for iroh, supporting both relay …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a pkarr publisher which uses the number 0 pkarr …\nCreates a pkarr resolver which uses the number 0 pkarr …\nCreates a new publisher for the <code>SecretKey</code>.\nCreates a new publisher using the pkarr relay server at …\nCreates a new client.\nPublishes a <code>SignedPacket</code>.\nResolves a <code>SignedPacket</code> for the given <code>NodeId</code>.\nPublishes <code>AddrInfo</code> about this node to a pkarr relay.\nCreates a new <code>PkarrPublisher</code> with a custom TTL and …\nBuilder for <code>DhtDiscovery</code>.\nPkarr Mainline DHT and relay server node discovery.\nBuilds the discovery mechanism.\nCreates a new builder for <code>DhtDiscovery</code>.\nExplicitly sets the pkarr client to use.\nSets whether to publish to the Mainline DHT.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSets whether to include the direct addresses in the DNS …\nSets the initial delay before the first publish.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUses the default number 0 pkarr relay URL.\nSets the pkarr relay URL to use.\nSets the republish delay for the DHT.\nSets the secret key to use for signing the DNS packets.\nSets the time-to-live value for the DNS packets.\nThe provenance string for this discovery implementation.\nA static discovery implementation that allows providing …\nAdd node info for the given node id, combining it with any …\nReturns the argument unchanged.\nCreates a static discovery instance from something that …\nGet node info for the given node id.\nCalls <code>U::from(self)</code>.\nCreate a new static discovery instance.\nRemove node info for the given node id.\nAdd node info for the given node id.\nThe DNS resolver type used throughout <code>iroh</code>.\nExtension trait to <code>DnsResolver</code>.\nGet a reference to the default DNS resolver.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by <code>NodeId</code> and origin domain name.\nLooks up node info by DNS name.\nLooks up node info by DNS name.\nLooks up node info by DNS name in a staggered fashion.\nLooks up node info by DNS name in a staggered fashion.\nPerform an ipv4 lookup with a timeout.\nRace an ipv4 and ipv6 lookup with a timeout.\nResolve IPv4 and IPv6 in parallel.\nRace an ipv4 and ipv6 lookup with a timeout in a staggered …\nRace an ipv4 and ipv6 lookup with a timeout in a staggered …\nPerform an ipv4 lookup with a timeout in a staggered …\nPerform an ipv4 lookup with a timeout in a staggered …\nPerform an ipv6 lookup with a timeout.\nPerform an ipv6 lookup with a timeout in a staggered …\nPerform an ipv6 lookup with a timeout in a staggered …\nSupport for handling DNS resource records for dialing by …\nGet the DNS resolver used within iroh.\nDirect address.\nThe DNS name for the iroh TXT record.\nThe attributes supported by iroh for <code>IROH_TXT_NAME</code> DNS …\nInformation about the iroh node contained in an …\nURL of home relay.\nAttributes parsed from <code>IROH_TXT_NAME</code> TXT records.\nReturns the parsed attributes.\nAny direct addresses.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParses a <code>NodeInfo</code> from a set of DNS records.\nParses a set of DNS resource records.\nCreates <code>TxtAttrs</code> from a node id and an iterator of …\nParses a <code>NodeInfo</code> from a <code>pkarr::SignedPacket</code>.\nParses a <code>pkarr::SignedPacket</code>.\nCreates <code>TxtAttrs</code> from a node id and an iterator of “…\nParses a <code>NodeId</code> from [<code>z-base-32</code>] encoding.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLooks up attributes by <code>NodeId</code> and origin domain.\nLooks up attributes by DNS name.\nCreates a new <code>NodeInfo</code> from its parts.\nReturns the node id.\nThe <code>NodeId</code>.\nThe advertised home relay server.\nConverts into a <code>hickory_proto::rr::Record</code> DNS record.\nConverts to a list of <code>hickory_proto::rr::Record</code> resource …\nCreates a <code>pkarr::SignedPacket</code>.\nCreates a <code>pkarr::SignedPacket</code>\nEncodes a <code>NodeId</code> in [<code>z-base-32</code>] encoding.\nthe endpoint has reached the confidentiality or integrity …\nthe application or application protocol caused the …\nFuture produced by <code>Endpoint::accept</code>.\nFuture produced by <code>Connection::accept_bi</code>\nFuture produced by <code>Connection::accept_uni</code>\nParameters for controlling the peer’s acknowledgement …\nNetwork paths to contact an iroh node.\nOptions to configure what is included in a <code>NodeAddr</code> and …\nIncludes the Node ID and the direct addresses.\nA key for sealing data with AEAD-based algorithms\nApplication layer added the address directly.\nReason given by an application for closing the connection\nThe peer closed the connection\nBuilder for <code>Endpoint</code>.\nA cheaply cloneable and sliceable chunk of contiguous …\nthe number of connection IDs provided by the peer exceeds …\nthe server refused to accept a new connection\nreceived more data in CRYPTO frames than can be buffered\nWe received a CallMeMaybe.\nA chunk of data from the receive stream\nThe connection could not be created because not enough of …\nError indicating that a stream has not been opened or has …\nThe stream has already been stopped, finished, or reset\nThe stream has already been finished or reset\nIn-progress connection attempt future\nA QUIC connection.\nReason given by the transport for closing the connection\nThe peer’s QUIC stack aborted the connection …\nReasons why a connection might be lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nThe connection was lost\nConnection statistics\nThe type of connection we have to the endpoint.\nStream returning <code>ConnectionTypes</code>\nThe type of control message we have received.\nCommon interface for different congestion controllers\nConstructs controllers on demand\nGeneric crypto errors\nServer-side configuration for the crypto protocol\nUse a custom relay map.\nUse the default relay map, with production relay servers …\nDirect UDP connection\nA <em>direct address</em> on which an iroh-node might be …\nInformation about a <em>direct address</em>.\nThe type of direct address.\nStream returning local endpoints as they change.\nDatagram support is disabled locally\nDisable relay servers completely.\nThe address was discovered by a discovery service.\nEnvironment variable to force the use of staging relays.\nControls an iroh node, establishing connections with other …\nError returned by Session::export_keying_material.\nreceived a STREAM frame or a RESET_STREAM frame containing …\nreceived more data than permitted in advertised data limits\nreceived a frame that was badly formatted\nThe stream finished before all bytes were read\nNumber of frames transmitted of each frame type\nA pseudo random key for HKDF\nthe endpoint encountered an internal error and cannot …\nreceived an invalid Retry Token in a client Initial\nOnly the Node ID is added.\nAttempted an ordered read following an unordered read\nAn incoming connection for which the server has not yet …\nAdaptor to let <code>Incoming</code> be <code>await</code>ed like a <code>Connecting</code>.\nkey update error\nA locally bound socket address.\nThe local application closed the connection\nThe largest representable value\nThe largest encoded value length\nBoth a UDP and a relay connection are used.\nParameters governing MTU discovery.\nthe connection is being closed abruptly in the absence of …\nno viable network path exists\nApplication layer with a specific name added the node …\nNetwork-level addressing information for an iroh node.\nWe have no verified connection to this PublicKey\nFuture produced by <code>Connection::open_bi</code>\nFuture produced by <code>Connection::open_uni</code>\ndetected an error with protocol compliance that was not …\nStatistics related to a transmission path\nWe received a Ping from the node.\nWe received a Pong from the node.\nAn address assigned by the router using port mapping.\nAn error occurred during reading\nFuture produced by <code>Connection::read_datagram</code>\nErrors that arise from reading from a stream.\nA read error occurred\nErrors that arise from reading from a stream.\nErrors from <code>RecvStream::read_to_end</code>\nA stream that can only be used to receive data\nIncludes the Node ID and the relay URL.\nRelay connection over relay\nA node communicated with us first via relay.\nIncludes the Node ID and both the relay URL, and the …\nConfiguration of the relay servers for an <code>Endpoint</code>.\nDetails about a remote iroh node which is known to this …\nThe peer abandoned transmitting data on this stream\nThe peer is unable to continue processing this connection, …\nErrors that arise while waiting for a stream to be reset\nError for attempting to retry an <code>Incoming</code> which already …\nreceived a frame for a stream identifier that exceeded …\nreceived a frame for a stream that was not in a state that …\nAddress was loaded from the fs.\nErrors that can arise when sending a datagram\nA stream that can only be used to send data\nParameters governing incoming connections\nThe origin or <em>source</em> through which an address associated …\nUse the staging relay servers from n0.\nThe peer is no longer accepting data on this stream\nErrors that arise while monitoring for a send stream stop …\nIdentifier for a stream within a particular connection\nPublic internet address discovered via STUN.\nHard NAT: STUN’ed IPv4 address + local fixed port.\nreceived transport parameters that were badly formatted, …\nCommunication with the peer has lapsed for longer than the …\nThe datagram is larger than the connection can currently …\nThe stream is larger than the user-supplied limit\nParameters governing the core QUIC state machine\nTransport-level errors occur when a peer violates the …\nThe peer violated the QUIC specification as understood by …\nTransport-level error code\nA node communicated with us first via UDP.\nStatistics about UDP datagrams transmitted or received on …\nNot yet determined..\nThe peer does not support receiving datagram frames\nError indicating that the specified QUIC version is not …\nAn integer less than 2^62\nThe peer doesn’t implement any supported version\nA handle to some connection internals, use with care.\nErrors that arise from writing to a stream\nIndicates how many bytes and chunks had been transferred …\nFuture that completes when a connection is fully …\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nThis was a 0-RTT stream and the server rejected it\nAccepts an incoming connection on the endpoint.\nAttempts to accept this incoming connection (an error may …\nAccept the next incoming bidirectional stream\nAccept the next incoming uni-directional stream\nAccepts this incoming connection using a custom …\nThe ack-eliciting threshold we will request the peer to use\nSpecifies the ACK frequency config (see <code>AckFrequencyConfig</code> …\nAdds a discovery mechanism for this endpoint.\nInforms this <code>Endpoint</code> about addresses of the iroh node.\nInforms this <code>Endpoint</code> about addresses of the iroh node, …\nThe UDP address reported by the remote node.\nThe address.\nThe addresses at which this node might be reachable.\nDerive AEAD using hkdf\nWhether the implementation is permitted to set the spin …\nExtracts the ALPN protocol from the peer’s handshake …\nSets the ALPN protocols that this endpoint will accept on …\nBinds the magic endpoint.\nSets the IPv4 bind address.\nSets the IPv6 bind address.\nSpecifies the amount of time that MTU discovery should …\nThe number of times a black hole was detected in the path\nReturns the local socket addresses on which the underlying …\nConstruct a fresh <code>Controller</code>\nReturns the builder for an <code>Endpoint</code>, with a production …\nThe contents of the chunk\nThe total amount of bytes which have been transferred …\nThe amount of bytes which had been written\nThe amount of full chunks which had been written\nClears the buffer, removing all data.\nRemoves all discovery services from the builder.\nDuplicate the controller’s state\nClose the connection immediately.\nCloses the QUIC endpoint and the magic socket.\nIf the connection is closed, the reason why.\nWait for the connection to be closed for any reason\nType of error\nHow to construct new <code>congestion::Controller</code>s\nCongestion events on the connection\nCurrent state of the congestion control algorithm, for …\nThe type of connection we have to the node, either direct …\nReturns a stream that reports connection type changes for …\nConnects to a remote <code>Endpoint</code>.\nConnects to a remote endpoint, using just the nodes’s …\nCreates <code>Bytes</code> instance from slice, by copying it.\nCreate QUIC error code from TLS alert code\nTLS configuration used for incoming connections.\nMaximum quantity of out-of-order crypto layer data to …\nLargest UDP payload size the path currently supports\nCurrent congestion window of the connection\nMaximum number of incoming application datagram bytes to …\nMaximum number of outgoing application datagram bytes to …\nBytes available in the outgoing datagram buffer\nThe amount of UDP datagrams observed\nReturns the default relay mode.\nWhich directions data flows in\nReturns the direct addresses of this <code>Endpoint</code>.\nSocket addresses where the peer might be reached directly.\nOptionally sets a discovery mechanism for this endpoint.\nReturns the discovery mechanism, if configured.\nConfigures the endpoint to also use the mainline DHT with …\nConfigures the endpoint to also use local network …\nConfigures the endpoint to use the default n0 DNS …\nOptionally sets a custom DNS resolver to use for this …\nReturns the DNS resolver used in this <code>Endpoint</code>.\nWhether to use “Generic Segmentation Offload” to …\nClass of error as encoded in the specification\nApplication-specific reason code\nDerive keying material from this connection’s TLS …\nNotify the peer that no more data will ever be written to …\nReturns <code>true</code> if the use of staging relays is forced.\nFrame type that triggered the error\nStatistics about frames received on a connection\nStatistics about frames transmitted on a connection\nType of frame that caused the close\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate Bytes with a buffer whose lifetime is controlled …\nCreates a new <code>Bytes</code> from a static slice.\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nExtract the <code>PublicKey</code> from the peer’s TLS certificate.\nParameters negotiated during the handshake\nParameters negotiated during the handshake\nWhether there is a possible known network path to the …\nReturns the <code>RelayUrl</code> of the Relay server used as home …\nGet the identity of this stream\nGet the identity of this stream\nIgnores this incoming connection attempt, not sending any …\nMaximum number of received bytes to buffer for each …\nMaximum number of received bytes to buffer for all <code>Incoming</code>\nDistinguishes streams of the same initiator and …\nAddressing information to connect to <code>Self::node_id</code>.\nCreate the initial set of keys given the client’s …\nThe initial value to be used as the maximum UDP payload …\nThe RTT used before an RTT sample is taken\nInitial congestion window\nWhich side of a connection initiated the stream\nSkip verification of SSL certificates from relay servers\nSpecifies the time to wait after completing MTU discovery …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a 0-RTT or 0.5-RTT connection at the cost of …\nReturns Self for use in down-casting to extract …\nGet the <code>Incoming</code>\nExtract the integer value\nThe amount of I/O operations executed\nCheck if this stream has been opened during 0-RTT.\nReturns <code>true</code> if the <code>Connection</code> associated with this handle …\nReturns true if the <code>Bytes</code> has a length of 0.\nReturns true if this is the only reference to the data and …\nPeriod of inactivity before sending a keep-alive packet\nEnables saving the TLS pre-master key for connections.\nOptionally set a list of known nodes.\nElapsed time since this network path was known to exist.\nLast control message received by this node about this …\nElapsed time since the last payload message was received …\nGet the duration since the last activity we received from …\nTime elapsed time since last we have sent to or received …\nThe latency to the remote node over this network path.\nThe latency of the current network path to the remote node.\nReturns the number of bytes contained in this <code>Bytes</code>.\nThe local IP address which was used when the peer …\nReturns the local IP address which was used when the peer …\nThe local IP address which was used when the peer …\nThe amount of bytes lost on this path\nThe amount of packets lost on this path\nThe amount of PLPMTUD probe packets lost on this path …\nCreates a <code>ServerConfig</code> with the given secret key and …\nThe <code>max_ack_delay</code> we will request the peer to use\nMaximum number of incoming bidirectional streams that may …\nVariant of <code>max_concurrent_bidi_streams</code> affecting …\nCompute the maximum size of datagrams that may be passed …\nMaximum duration of inactivity to accept before timing out …\nMaximum number of <code>Incoming</code> to allow to exist at a time\nWhether to allow clients to migrate to new addresses\nThe maximum UDP payload size guaranteed to be supported by …\nSpecifies the minimum MTU change to stop the MTU discovery …\nSpecifies the MTU discovery config (see <code>MtuDiscoveryConfig</code> …\nNotifies the system of potential network changes.\nResets path-specific state.\nCreates a new empty <code>Bytes</code>.\nCreate a default config with a particular handshake token …\nCreate a new StreamId\nReturns the current <code>NodeAddr</code> for this endpoint.\nReturns the node id of this endpoint.\nThe node’s identifier.\nThe globally unique identifier for this node.\nTrack changed on our external address as reported by the …\nThe offset in the stream\nPacket deliveries were confirmed\nPackets were deemed lost or marked congested\nPackets are acked in batches, all with the same <code>now</code> …\nThe known MTU for the current network path has been updated\nOne or more packets were just sent\nMethod for opening a sealed message <code>data</code>\nInitiate a new outgoing bidirectional stream.\nInitiate a new outgoing unidirectional stream.\nMaximum reordering in packet number space before FACK …\nStatistics related to the current transmission path\nCryptographic identity of the peer\nNumber of consecutive PTOs after which network is …\nAttempts to read from the stream into buf.\nAttempt to write bytes from buf into the stream.\nThe preferred IPv4 address that will be communicated to …\nThe preferred IPv6 address that will be communicated to …\nGet the priority of the send stream\nSets the proxy url from the environment, in this order:\nSets an explicit proxy url to proxy all HTTP(S) traffic …\nRead data contiguously from the stream.\nRead the next segment of data\nRead the next segments of data\nReceive an application datagram\nRead an exact number of bytes contiguously from the stream.\nConvenience method to read all remaining data into a buffer\nHuman-readable reason for the close\nHuman-readable reason for the close\nHuman-readable explanation of the reason\nWhether to receive observed address reports from other …\nMaximum number of bytes the peer may transmit across all …\nCompletes when the stream has been reset by the peer or …\nRejects this incoming connection attempt.\nReturns the relay map for this mode.\nSets the relay servers to assist in establishing …\nThe node’s home relay url.\nRelay server information, if available.\nThe peer’s UDP address\nReturns the peer’s UDP address.\nThe peer’s UDP address.\nWhether the socket address that is initiating this …\nReturns information about the remote node identified by a …\nReturns information about all the remote nodes this …\nThe reordering threshold we will request the peer to use\nClose the send stream immediately.\nResponds with a retry packet.\nGenerate the integrity tag for a retry packet\nDuration after a stateless retry token was issued for …\nCurrent best estimate of this connection’s latency …\nCurrent best estimate of this connection’s latency …\nSaturating integer addition. Computes self + rhs, …\nMethod for sealing message <code>data</code>\nSets a secret key to authenticate with other peers.\nReturns the secret_key of this endpoint.\nTransmit <code>data</code> as an unreliable, unordered application …\nTransmit <code>data</code> as an unreliable, unordered application …\nWhether to send observed address reports to peers.\nMaximum number of bytes to transmit to a peer without …\nThe amount of packets sent on this path\nThe amount of PLPMTUD probe packets sent on this path …\nSets the list of accepted ALPN protocols.\nModify the number of remotely initiated bidirectional …\nModify the number of remotely initiated unidirectional …\nSet the priority of the send stream\nSee <code>proto::TransportConfig::receive_window()</code>\nReturns a slice of self for the provided range.\nReturns a slice of self that is equivalent to the given …\nReturns a deduplicated list of <code>Source</code>s merged from all …\nA <code>HashMap</code> of <code>Source</code>s to <code>Duration</code>s.\nSplits the bytes into two at the given index.\nSplits the bytes into two at the given index.\nA stable identifier for this connection\nStart a server session with this configuration\nReturns connection statistics\nStop accepting data\nCompletes when the peer stops the stream or reads the …\nMaximum number of bytes the peer may transmit without …\nMaximum reordering in time space before time based loss …\nPrivate key used to authenticate data included in …\nTransport configuration to use for incoming connections\nSets a custom <code>quinn::TransportConfig</code> for this endpoint.\nSet a custom <code>TransportConfig</code>\nShortens the buffer, keeping the first <code>len</code> bytes and …\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nTry to convert self into <code>BytesMut</code>.\nThe origin of this direct address.\nStatistics about UDP datagrams received on a connection\nStatistics about UDP datagrams transmitted on a connection\nSpecifies the upper bound to the max UDP payload size that …\nWatches for changes to the home relay.\nReturns a weak reference to the inner connection struct.\nNumber of ack-eliciting bytes that may be in flight\nCreate a server config with the given <code>crypto::ServerConfig</code>\nCreate a server config with the given certificate chain to …\nWrite bytes to the stream\nConvenience method to write an entire buffer to the stream\nConvenience method to write an entire list of chunks to …\nConvenience method to write a single chunk in its entirety …\nWrite chunks to the stream\nThe name of the discovery service that discovered the …\nThe name of the application that added the node\nA format identifier\nThe hash for the empty byte range (<code>b&quot;&quot;</code>).\nHash type used throughout.\nA hash and format pair\nA sequence of BLAKE3 hashes\nRaw blob\nBytes of the hash.\nConvert to a base32 string limited to the first 10 bytes …\nThe format\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Hash</code> from its raw bytes representation.\nThe hash\nCreate a new hash and format pair, using the collection …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs hash seq format\nIs raw format\nCalculate the hash of the provided bytes.\nCreate a new hash and format pair.\nCreate a new hash and format pair, using the default (raw) …\nConvert the hash to a hex string.\nSize of an encoded Ed25519 signature in bytes.\nError when decoding the base32.\nError when decoding the public key.\nError when deserialising a <code>PublicKey</code> or a <code>SecretKey</code>.\nThe identifier for a node in the (iroh) network.\nThe length of an ed25519 <code>PublicKey</code>, in bytes.\nA public key.\nA secret key.\nShared Secret.\nEd25519 signature.\nGet this public key as a byte array.\nConvert to a base32 string limited to the first 10 bytes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nParse an Ed25519 signature from a byte slice.\nConstruct a <code>PublicKey</code> from a slice of bytes.\nCreate a secret key from its byte representation.\nParse an Ed25519 signature from its <code>R</code> and <code>s</code> components.\nParse an Ed25519 signature from a byte slice.\nGenerate a new <code>SecretKey</code> with the default randomness …\nGenerate a new <code>SecretKey</code> with a randomness generator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOpens the ciphertext, which must have been created using …\nThe public key of this <code>SecretKey</code>.\nBytes for the <code>R</code> component of a signature.\nBytes for the <code>s</code> component of a signature.\nSeals the provided cleartext.\nReturns the shared key for communication between this key …\nSign the given message and return a digital signature\nReturn the inner byte array.\nConvert this to the bytes representing the secret part. …\nSerialise this key to OpenSSH format.\nConvert this signature into a byte vector.\nDeserialise this key from OpenSSH format.\nVerify a signature on a message with this secret key’s …\nEnum of metrics for the module\nEnum of metrics for the module\nEnum of metrics for the module\nMetrics tracked for the relay server\nNumber of connections we have accepted\nBytes received from a <code>FrameType::SendPacket</code>\nBytes sent from a <code>FrameType::SendPacket</code>\nNumber of connections with a successful handshake that …\nNumber of connections with a successful handshake.\nNumber of client connections which have had any frames …\nNumber of accepted ‘iroh derp http’ connection upgrades\n<code>FrameType::SendPacket</code> dropped that are disco messages\n<code>FrameType::SendPacket</code> received that are disco messages\n<code>FrameType::SendPacket</code> sent that are disco messages\nNumber of connections we have removed because of an error\nNumber of frames received from client connection which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNumber of <code>FrameType::Ping</code>s received\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of nodes we have attempted to contact.\nNumber of nodes we have managed to contact directly.\nThe number of direct connections we have made to peers.\nThe number of direct connections we have lost to peers.\nThe number of connections to peers we have added over …\nThe number of connections to peers we have removed over …\nPackets of other <code>FrameType</code>s dropped\nPackets of other <code>FrameType</code>s received\nPackets of other <code>FrameType</code>s sent\nNumber of QUIC datagrams received.\nNumber of datagrams received using GRO\n<code>FrameType::SendPacket</code> dropped, that are not disco messages\n<code>FrameType::SendPacket</code> received, that are not disco messages\n<code>FrameType::SendPacket</code> sent, that are not disco messages\nNumber of <code>FrameType::Pong</code>s sent\nNumber of unique client keys per day\nNumber of <code>FrameType::Unknown</code> received\nNumber of accepted websocket connections\nHelper trait to facilite casting from <code>Arc&lt;dyn T&gt;</code> to …\nHandler for incoming connections.\nA typed map of protocol handlers, mapping them from ALPNs.\nThe built router.\nBuilder for creating a <code>Router</code> for accepting protocols.\nHandle an incoming connection.\nConfigures the router to accept the <code>ProtocolHandler</code> when …\nReturns an iterator of all registered ALPN protocol …\nCreates a new <code>Router</code> using given <code>Endpoint</code>.\nReturns the <code>Endpoint</code> stored in this router.\nReturns the <code>Endpoint</code> of the node.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the registered protocol handler for an ALPN as a …\nReturns a protocol handler for an ALPN.\nReturns a protocol handler for an ALPN.\nReturns the registered protocol handler for an ALPN as a …\nInserts a protocol handler.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCasts <code>Arc&lt;Self&gt;</code> into <code>Arc&lt;dyn Any + Send + Sync&gt;</code>.\nChecks if the router is already shutdown.\nCreates a new router builder using given <code>Endpoint</code>.\nCalled when the node shuts down.\nShuts down the accept loop cleanly.\nShuts down all protocol handlers.\nSpawns an accept loop and returns a handle to it …\nA drop guard to clean up test infrastructure.\nHandle and drop guard for test DNS and Pkarr servers.\nCreate a DNS resolver with a single nameserver.\nCreate a <code>ConcurrentDiscovery</code> with <code>DnsDiscovery</code> and …\nCreate a <code>DnsResolver</code> configured to use the test DNS server.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe socket address of the DNS server.\nThe node origin domain.\nWait until a Pkarr announce for a node is published to the …\nThe HTTP URL of the Pkarr server.\nRun DNS and Pkarr servers on localhost.\nRuns a relay server with STUN and QUIC enabled suitable …\nRuns a relay server.\nRuns a relay server with STUN enabled suitable for tests.\nRun DNS and Pkarr servers on localhost with the specified …\nA token containing everything to get a file from the …\nThis looks like a ticket, but base32 decoding failed.\nAn error deserializing an iroh ticket.\nString prefix describing the kind of iroh ticket.\nFound a ticket of with the wrong prefix, indicating the …\nA token containing information for establishing a …\nThis looks like a ticket, but postcard deserialization …\nA ticket is a serializable object combining information …\nVerification of the deserialized bytes failed.\nDeserialize from a string.\nThe <code>BlobFormat</code> for this ticket.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a ticket from given addressing info.\nReturns the argument unchanged.\nDeserialize from the base32 string representation bytes.\nThe hash of the item this ticket can retrieve.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the contents of the ticket, consuming it.\nCreates a new ticket.\nCreates a new ticket.\nThe <code>NodeAddr</code> of the provider for this ticket.\nThe <code>NodeAddr</code> of the provider for this ticket.\nTrue if the ticket is for a collection and should retrieve …\nSerialize to string.\nSerialize to bytes used in the base32 string …\nError generating the certificate.\nError creating QUIC config.\nError for generating iroh p2p TLS configs.\nX.509 certificate handling.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a TLS client configuration.\nCreate a TLS server configuration.\nAn error that occurs during certificate generation.\nAn X.509 certificate with a libp2p-specific extension is …\nThe contents of the specific libp2p extension, containing …\nAn error that occurs during certificate parsing.\nAn error that occurs during signature verification.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a self-signed TLS certificate that includes a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAttempts to parse the provided bytes as a <code>P2pCertificate</code>.\nThe <code>PublicKey</code> of the remote peer.\nVerify the <code>signature</code> of the <code>message</code> signed by the secret …")